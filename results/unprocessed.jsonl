{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_middleware.py", "kind": "class_docstring", "text": "Context object for chat middleware invocations.\n\n    This context is passed through the chat middleware pipeline and contains all information\n    about the chat request.\n\n    Attributes:\n        chat_client: The chat client being invoked.\n        messages: The messages being sent to the chat client.\n        chat_options: The options for the chat request.\n        is_streaming: Whether this is a streaming invocation.\n        metadata: Metadata dictionary for sharing data between chat middleware.\n        result: Chat execution result. Can be observed after calling ``next()``\n                to see the actual execution result or can be set to override the execution result.\n                For non-streaming: should be ChatResponse.\n                For streaming: should be AsyncIterable[ChatResponseUpdate].\n        terminate: A flag indicating whether to terminate execution after current middleware.\n                When set to True, execution will stop as soon as control returns to framework.\n        kwargs: Additional keyword arguments passed to the chat client.\n\n    Examples:\n        .. code-block:: python\n\n            from agent_framework import ChatMiddleware, ChatContext\n\n\n            class TokenCounterMiddleware(ChatMiddleware):\n                async def process(self, context: ChatContext, next):\n                    print(f\"Chat client: {context.chat_client.__class__.__name__}\")\n                    print(f\"Messages: {len(context.messages)}\")\n                    print(f\"Model: {context.chat_options.model_id}\")\n\n                    # Store metadata\n                    context.metadata[\"input_tokens\"] = self.count_tokens(context.messages)\n\n                    # Continue execution\n                    await next(context)\n\n                    # Access result and count output tokens\n                    if context.result:\n                        context.metadata[\"output_tokens\"] = self.count_tokens(context.result)\n    ", "meta": {"scope": ["ChatContext"], "position": {"start": {"line": 201, "column": 4}, "end": {"line": 241, "column": 7}}, "target": "ChatContext", "qualname": "ChatContext"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_middleware.py", "kind": "function_docstring", "text": "Initialize the ChatContext.\n\n        Args:\n            chat_client: The chat client being invoked.\n            messages: The messages being sent to the chat client.\n            chat_options: The options for the chat request.\n            is_streaming: Whether this is a streaming invocation.\n            metadata: Metadata dictionary for sharing data between chat middleware.\n            result: Chat execution result.\n            terminate: A flag indicating whether to terminate execution after current middleware.\n            kwargs: Additional keyword arguments passed to the chat client.\n        ", "meta": {"scope": ["ChatContext", "__init__"], "position": {"start": {"line": 256, "column": 8}, "end": {"line": 267, "column": 11}}, "target": "__init__", "qualname": "ChatContext::__init__"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_middleware.py", "kind": "class_docstring", "text": "Abstract base class for agent middleware that can intercept agent invocations.\n\n    Agent middleware allows you to intercept and modify agent invocations before and after\n    execution. You can inspect messages, modify context, override results, or terminate\n    execution early.\n\n    Note:\n        AgentMiddleware is an abstract base class. You must subclass it and implement\n        the ``process()`` method to create custom agent middleware.\n\n    Examples:\n        .. code-block:: python\n\n            from agent_framework import AgentMiddleware, AgentRunContext, ChatAgent\n\n\n            class RetryMiddleware(AgentMiddleware):\n                def __init__(self, max_retries: int = 3):\n                    self.max_retries = max_retries\n\n                async def process(self, context: AgentRunContext, next):\n                    for attempt in range(self.max_retries):\n                        await next(context)\n                        if context.result and not context.result.is_error:\n                            break\n                        print(f\"Retry {attempt + 1}/{self.max_retries}\")\n\n\n            # Use with an agent\n            agent = ChatAgent(chat_client=client, name=\"assistant\", middleware=RetryMiddleware())\n    ", "meta": {"scope": ["AgentMiddleware"], "position": {"start": {"line": 279, "column": 4}, "end": {"line": 309, "column": 7}}, "target": "AgentMiddleware", "qualname": "AgentMiddleware"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_middleware.py", "kind": "function_docstring", "text": "Process an agent invocation.\n\n        Args:\n            context: Agent invocation context containing agent, messages, and metadata.\n                    Use context.is_streaming to determine if this is a streaming call.\n                    Middleware can set context.result to override execution, or observe\n                    the actual execution result after calling next().\n                    For non-streaming: AgentRunResponse\n                    For streaming: AsyncIterable[AgentRunResponseUpdate]\n            next: Function to call the next middleware or final agent execution.\n                  Does not return anything - all data flows through the context.\n\n        Note:\n            Middleware should not return anything. All data manipulation should happen\n            within the context object. Set context.result to override execution,\n            or observe context.result after calling next() for actual results.\n        ", "meta": {"scope": ["AgentMiddleware", "process"], "position": {"start": {"line": 317, "column": 8}, "end": {"line": 333, "column": 11}}, "target": "process", "qualname": "AgentMiddleware::process"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_middleware.py", "kind": "class_docstring", "text": "Abstract base class for function middleware that can intercept function invocations.\n\n    Function middleware allows you to intercept and modify function/tool invocations before\n    and after execution. You can validate arguments, cache results, log invocations, or\n    override function execution.\n\n    Note:\n        FunctionMiddleware is an abstract base class. You must subclass it and implement\n        the ``process()`` method to create custom function middleware.\n\n    Examples:\n        .. code-block:: python\n\n            from agent_framework import FunctionMiddleware, FunctionInvocationContext, ChatAgent\n\n\n            class CachingMiddleware(FunctionMiddleware):\n                def __init__(self):\n                    self.cache = {}\n\n                async def process(self, context: FunctionInvocationContext, next):\n                    cache_key = f\"{context.function.name}:{context.arguments}\"\n\n                    # Check cache\n                    if cache_key in self.cache:\n                        context.result = self.cache[cache_key]\n                        context.terminate = True\n                        return\n\n                    # Execute function\n                    await next(context)\n\n                    # Cache result\n                    if context.result:\n                        self.cache[cache_key] = context.result\n\n\n            # Use with an agent\n            agent = ChatAgent(chat_client=client, name=\"assistant\", middleware=CachingMiddleware())\n    ", "meta": {"scope": ["FunctionMiddleware"], "position": {"start": {"line": 338, "column": 4}, "end": {"line": 377, "column": 7}}, "target": "FunctionMiddleware", "qualname": "FunctionMiddleware"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_middleware.py", "kind": "function_docstring", "text": "Process a function invocation.\n\n        Args:\n            context: Function invocation context containing function, arguments, and metadata.\n                    Middleware can set context.result to override execution, or observe\n                    the actual execution result after calling next().\n            next: Function to call the next middleware or final function execution.\n                  Does not return anything - all data flows through the context.\n\n        Note:\n            Middleware should not return anything. All data manipulation should happen\n            within the context object. Set context.result to override execution,\n            or observe context.result after calling next() for actual results.\n        ", "meta": {"scope": ["FunctionMiddleware", "process"], "position": {"start": {"line": 385, "column": 8}, "end": {"line": 398, "column": 11}}, "target": "process", "qualname": "FunctionMiddleware::process"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_middleware.py", "kind": "class_docstring", "text": "Abstract base class for chat middleware that can intercept chat client requests.\n\n    Chat middleware allows you to intercept and modify chat client requests before and after\n    execution. You can modify messages, add system prompts, log requests, or override\n    chat responses.\n\n    Note:\n        ChatMiddleware is an abstract base class. You must subclass it and implement\n        the ``process()`` method to create custom chat middleware.\n\n    Examples:\n        .. code-block:: python\n\n            from agent_framework import ChatMiddleware, ChatContext, ChatAgent\n\n\n            class SystemPromptMiddleware(ChatMiddleware):\n                def __init__(self, system_prompt: str):\n                    self.system_prompt = system_prompt\n\n                async def process(self, context: ChatContext, next):\n                    # Add system prompt to messages\n                    from agent_framework import ChatMessage\n\n                    context.messages.insert(0, ChatMessage(role=\"system\", content=self.system_prompt))\n\n                    # Continue execution\n                    await next(context)\n\n\n            # Use with an agent\n            agent = ChatAgent(\n                chat_client=client, name=\"assistant\", middleware=SystemPromptMiddleware(\"You are a helpful assistant.\")\n            )\n    ", "meta": {"scope": ["ChatMiddleware"], "position": {"start": {"line": 403, "column": 4}, "end": {"line": 437, "column": 7}}, "target": "ChatMiddleware", "qualname": "ChatMiddleware"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_middleware.py", "kind": "function_docstring", "text": "Process a chat client request.\n\n        Args:\n            context: Chat invocation context containing chat client, messages, options, and metadata.\n                    Use context.is_streaming to determine if this is a streaming call.\n                    Middleware can set context.result to override execution, or observe\n                    the actual execution result after calling next().\n                    For non-streaming: ChatResponse\n                    For streaming: AsyncIterable[ChatResponseUpdate]\n            next: Function to call the next middleware or final chat execution.\n                  Does not return anything - all data flows through the context.\n\n        Note:\n            Middleware should not return anything. All data manipulation should happen\n            within the context object. Set context.result to override execution,\n            or observe context.result after calling next() for actual results.\n        ", "meta": {"scope": ["ChatMiddleware", "process"], "position": {"start": {"line": 445, "column": 8}, "end": {"line": 461, "column": 11}}, "target": "process", "qualname": "ChatMiddleware::process"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_middleware.py", "kind": "comment", "text": "Pure function type definitions for convenience", "meta": {"scope": [], "position": {"start": {"line": 465, "column": 0}, "end": {"line": 465, "column": 48}}, "comment_type": "block", "line_count": 1, "original_block": "# Pure function type definitions for convenience\n"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_middleware.py", "kind": "comment", "text": "Type alias for all middleware types", "meta": {"scope": [], "position": {"start": {"line": 474, "column": 0}, "end": {"line": 474, "column": 37}}, "comment_type": "block", "line_count": 1, "original_block": "# Type alias for all middleware types\n"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_middleware.py", "kind": "function_docstring", "text": "Decorator to mark a function as agent middleware.\n\n    This decorator explicitly identifies a function as agent middleware,\n    which processes AgentRunContext objects.\n\n    Args:\n        func: The middleware function to mark as agent middleware.\n\n    Returns:\n        The same function with agent middleware marker.\n\n    Examples:\n        .. code-block:: python\n\n            from agent_framework import agent_middleware, AgentRunContext, ChatAgent\n\n\n            @agent_middleware\n            async def logging_middleware(context: AgentRunContext, next):\n                print(f\"Before: {context.agent.name}\")\n                await next(context)\n                print(f\"After: {context.result}\")\n\n\n            # Use with an agent\n            agent = ChatAgent(chat_client=client, name=\"assistant\", middleware=logging_middleware)\n    ", "meta": {"scope": ["agent_middleware"], "position": {"start": {"line": 489, "column": 4}, "end": {"line": 515, "column": 7}}, "target": "agent_middleware", "qualname": "agent_middleware"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_middleware.py", "kind": "comment", "text": "region Middleware type markers for decorators", "meta": {"scope": ["agent_middleware"], "position": {"start": {"line": 485, "column": 0}, "end": {"line": 485, "column": 47}}, "comment_type": "block", "line_count": 1, "original_block": "# region Middleware type markers for decorators\n", "qualname": "agent_middleware"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_middleware.py", "kind": "comment", "text": "Add marker attribute to identify this as agent middleware", "meta": {"scope": ["agent_middleware"], "position": {"start": {"line": 516, "column": 4}, "end": {"line": 516, "column": 63}}, "comment_type": "block", "line_count": 1, "original_block": "    # Add marker attribute to identify this as agent middleware\n", "qualname": "agent_middleware"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_middleware.py", "kind": "function_docstring", "text": "Decorator to mark a function as function middleware.\n\n    This decorator explicitly identifies a function as function middleware,\n    which processes FunctionInvocationContext objects.\n\n    Args:\n        func: The middleware function to mark as function middleware.\n\n    Returns:\n        The same function with function middleware marker.\n\n    Examples:\n        .. code-block:: python\n\n            from agent_framework import function_middleware, FunctionInvocationContext, ChatAgent\n\n\n            @function_middleware\n            async def logging_middleware(context: FunctionInvocationContext, next):\n                print(f\"Calling: {context.function.name}\")\n                await next(context)\n                print(f\"Result: {context.result}\")\n\n\n            # Use with an agent\n            agent = ChatAgent(chat_client=client, name=\"assistant\", middleware=logging_middleware)\n    ", "meta": {"scope": ["function_middleware"], "position": {"start": {"line": 522, "column": 4}, "end": {"line": 548, "column": 7}}, "target": "function_middleware", "qualname": "function_middleware"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_middleware.py", "kind": "comment", "text": "Add marker attribute to identify this as function middleware", "meta": {"scope": ["function_middleware"], "position": {"start": {"line": 549, "column": 4}, "end": {"line": 549, "column": 66}}, "comment_type": "block", "line_count": 1, "original_block": "    # Add marker attribute to identify this as function middleware\n", "qualname": "function_middleware"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_middleware.py", "kind": "function_docstring", "text": "Decorator to mark a function as chat middleware.\n\n    This decorator explicitly identifies a function as chat middleware,\n    which processes ChatContext objects.\n\n    Args:\n        func: The middleware function to mark as chat middleware.\n\n    Returns:\n        The same function with chat middleware marker.\n\n    Examples:\n        .. code-block:: python\n\n            from agent_framework import chat_middleware, ChatContext, ChatAgent\n\n\n            @chat_middleware\n            async def logging_middleware(context: ChatContext, next):\n                print(f\"Messages: {len(context.messages)}\")\n                await next(context)\n                print(f\"Response: {context.result}\")\n\n\n            # Use with an agent\n            agent = ChatAgent(chat_client=client, name=\"assistant\", middleware=logging_middleware)\n    ", "meta": {"scope": ["chat_middleware"], "position": {"start": {"line": 555, "column": 4}, "end": {"line": 581, "column": 7}}, "target": "chat_middleware", "qualname": "chat_middleware"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_middleware.py", "kind": "comment", "text": "Add marker attribute to identify this as chat middleware", "meta": {"scope": ["chat_middleware"], "position": {"start": {"line": 582, "column": 4}, "end": {"line": 582, "column": 62}}, "comment_type": "block", "line_count": 1, "original_block": "    # Add marker attribute to identify this as chat middleware\n", "qualname": "chat_middleware"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_group_chat.py", "kind": "class_docstring", "text": "Executor that orchestrates a group chat between multiple participants using a manager.\n\n    This is the central runtime state machine that drives multi-agent conversations. It\n    maintains conversation state, delegates speaker selection to a manager, routes messages\n    to participants, and collects responses in a loop until the manager signals completion.\n\n    Core responsibilities:\n    - Accept initial input as str, ChatMessage, or list[ChatMessage]\n    - Maintain conversation history and turn tracking\n    - Query manager for next action (select participant or finish)\n    - Route requests to selected participants using AgentExecutorRequest or GroupChatRequestMessage\n    - Collect participant responses and append to conversation\n    - Enforce optional round limits to prevent infinite loops\n    - Yield final completion message and transition to idle state\n\n    State management:\n    - _conversation: Growing list of all messages (user, manager, agents)\n    - _history: Turn-by-turn record with speaker attribution and roles\n    - _task_message: Original user task extracted from input\n    - _pending_agent: Name of agent currently processing a request\n    - _round_index: Count of manager selection rounds for limit enforcement\n\n    Manager interaction:\n    The orchestrator builds immutable state snapshots and passes them to the manager\n    callable. The manager returns a GroupChatDirective indicating either:\n    - Next participant to speak (with optional instruction)\n    - Finish signal (with optional final message)\n\n    Message flow topology:\n        User input -> orchestrator -> manager -> orchestrator -> participant -> orchestrator\n        (loops until manager returns finish directive)\n\n    Why this design:\n    - Separates orchestration logic (this class) from selection logic (manager)\n    - Manager is stateless and testable in isolation\n    - Orchestrator handles all state mutations and message routing\n    - Broadcast routing to participants keeps graph structure simple\n\n    Args:\n        manager: Callable that selects the next participant or finishes based on state snapshot\n        participants: Mapping of participant names to descriptions (for manager context)\n        manager_name: Display name for manager in conversation history\n        max_rounds: Optional limit on manager selection rounds (None = unlimited)\n        executor_id: Optional custom ID for observability (auto-generated if not provided)\n    ", "meta": {"scope": ["GroupChatOrchestratorExecutor"], "position": {"start": {"line": 180, "column": 4}, "end": {"line": 224, "column": 7}}, "target": "GroupChatOrchestratorExecutor", "qualname": "GroupChatOrchestratorExecutor"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_group_chat.py", "kind": "comment", "text": "endregion\nregion Default orchestrator", "meta": {"scope": ["GroupChatOrchestratorExecutor"], "position": {"start": {"line": 173, "column": 0}, "end": {"line": 176, "column": 29}}, "comment_type": "block", "line_count": 2, "original_block": "# endregion\n\n\n# region Default orchestrator\n", "qualname": "GroupChatOrchestratorExecutor"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_group_chat.py", "kind": "comment", "text": "Stashes the initial conversation list until _handle_task_message normalizes it into _conversation.", "meta": {"scope": ["GroupChatOrchestratorExecutor", "__init__"], "position": {"start": {"line": 243, "column": 8}, "end": {"line": 243, "column": 108}}, "comment_type": "block", "line_count": 1, "original_block": "        # Stashes the initial conversation list until _handle_task_message normalizes it into _conversation.\n", "qualname": "GroupChatOrchestratorExecutor::__init__"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_group_chat.py", "kind": "function_docstring", "text": "Get the manager name for orchestrator-generated messages.", "meta": {"scope": ["GroupChatOrchestratorExecutor", "_get_author_name"], "position": {"start": {"line": 247, "column": 8}, "end": {"line": 247, "column": 71}}, "target": "_get_author_name", "qualname": "GroupChatOrchestratorExecutor::_get_author_name"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_group_chat.py", "kind": "function_docstring", "text": "Build a snapshot of current orchestration state for the manager.\n\n        Packages conversation history, participant metadata, and round tracking into\n        an immutable mapping that the manager uses to make speaker selection decisions.\n\n        Returns:\n            Mapping containing all context needed for manager decision-making\n\n        Raises:\n            RuntimeError: If called before task message initialization (defensive check)\n\n        When this is called:\n            - After initial input is processed (first manager query)\n            - After each participant response (subsequent manager queries)\n        ", "meta": {"scope": ["GroupChatOrchestratorExecutor", "_build_state"], "position": {"start": {"line": 251, "column": 8}, "end": {"line": 265, "column": 11}}, "target": "_build_state", "qualname": "GroupChatOrchestratorExecutor::_build_state"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_group_chat.py", "kind": "function_docstring", "text": "Serialize GroupChat-specific state for checkpointing.\n\n        Returns:\n            Dict with participants, manager name, history, and pending agent\n        ", "meta": {"scope": ["GroupChatOrchestratorExecutor", "_snapshot_pattern_metadata"], "position": {"start": {"line": 279, "column": 8}, "end": {"line": 283, "column": 11}}, "target": "_snapshot_pattern_metadata", "qualname": "GroupChatOrchestratorExecutor::_snapshot_pattern_metadata"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_group_chat.py", "kind": "function_docstring", "text": "Restore GroupChat-specific state from checkpoint.\n\n        Args:\n            metadata: Pattern-specific state dict\n        ", "meta": {"scope": ["GroupChatOrchestratorExecutor", "_restore_pattern_metadata"], "position": {"start": {"line": 296, "column": 8}, "end": {"line": 300, "column": 11}}, "target": "_restore_pattern_metadata", "qualname": "GroupChatOrchestratorExecutor::_restore_pattern_metadata"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_group_chat.py", "kind": "function_docstring", "text": "Execute a manager directive by either finishing the workflow or routing to a participant.\n\n        This is the core routing logic that interprets manager decisions. It handles two cases:\n        1. Finish directive: append final message, update state, yield output, become idle\n        2. Agent selection: build request envelope, route to participant, increment round counter\n\n        Args:\n            directive: Manager's decision (finish or select next participant)\n            ctx: Workflow context for sending messages and yielding output\n\n        Behavior for finish directive:\n            - Uses provided final_message or creates default completion message\n            - Ensures author_name is set to manager for attribution\n            - Appends to conversation and history for complete record\n            - Yields message as workflow output\n            - Orchestrator becomes idle (no further processing)\n\n        Behavior for agent selection:\n            - Validates agent_name exists in participants\n            - Optionally appends manager instruction as USER message\n            - Prepares full conversation context for the participant\n            - Routes request directly to the participant entry executor\n            - Increments round counter and enforces max_rounds if configured\n\n        Round limit enforcement:\n            If max_rounds is reached, recursively calls _apply_directive with a finish\n            directive to gracefully terminate the conversation.\n\n        Raises:\n            ValueError: If directive lacks agent_name when finish=False, or if\n                       agent_name doesn't match any participant\n        ", "meta": {"scope": ["GroupChatOrchestratorExecutor", "_apply_directive"], "position": {"start": {"line": 325, "column": 8}, "end": {"line": 356, "column": 11}}, "target": "_apply_directive", "qualname": "GroupChatOrchestratorExecutor::_apply_directive"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_group_chat.py", "kind": "comment", "text": "Use inherited routing method from BaseGroupChatOrchestrator", "meta": {"scope": ["GroupChatOrchestratorExecutor", "_apply_directive"], "position": {"start": {"line": 392, "column": 8}, "end": {"line": 392, "column": 69}}, "comment_type": "block", "line_count": 1, "original_block": "        # Use inherited routing method from BaseGroupChatOrchestrator\n", "qualname": "GroupChatOrchestratorExecutor::_apply_directive"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_group_chat.py", "kind": "function_docstring", "text": "Common response ingestion logic shared by agent and custom participants.", "meta": {"scope": ["GroupChatOrchestratorExecutor", "_ingest_participant_message"], "position": {"start": {"line": 420, "column": 8}, "end": {"line": 420, "column": 86}}, "target": "_ingest_participant_message", "qualname": "GroupChatOrchestratorExecutor::_ingest_participant_message"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_group_chat.py", "kind": "function_docstring", "text": "Select the final assistant message from an AgentExecutor response.", "meta": {"scope": ["GroupChatOrchestratorExecutor", "_extract_agent_message"], "position": {"start": {"line": 443, "column": 8}, "end": {"line": 443, "column": 80}}, "target": "_extract_agent_message", "qualname": "GroupChatOrchestratorExecutor::_extract_agent_message"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_group_chat.py", "kind": "function_docstring", "text": "Initialize orchestrator state and start the manager-directed conversation loop.\n\n        This internal method is called by all public handlers (str, ChatMessage, list[ChatMessage])\n        after normalizing their input. It initializes conversation state, queries the manager\n        for the first action, and applies the resulting directive.\n\n        Args:\n            task_message: The primary user task message (extracted or provided directly)\n            ctx: Workflow context for sending messages and yielding output\n\n        Behavior:\n            - Sets task_message for manager context\n            - Initializes conversation from pending_initial_conversation if present\n            - Otherwise starts fresh with just the task message\n            - Builds turn history with speaker attribution\n            - Resets pending_agent and round_index\n            - Queries manager for first action\n            - Applies directive to start the conversation loop\n\n        State initialization:\n            - _conversation: Full message list for context\n            - _history: Turn-by-turn record with speaker names and roles\n            - _pending_agent: None (no active request)\n            - _round_index: 0 (first manager query)\n\n        Why pending_initial_conversation exists:\n            The handle_conversation handler supplies an explicit task (the first message in\n            the list) but still forwards the entire conversation for context. The full list is\n            stashed in _pending_initial_conversation to preserve all context when initializing state.\n        ", "meta": {"scope": ["GroupChatOrchestratorExecutor", "_handle_task_message"], "position": {"start": {"line": 474, "column": 8}, "end": {"line": 503, "column": 11}}, "target": "_handle_task_message", "qualname": "GroupChatOrchestratorExecutor::_handle_task_message"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_group_chat.py", "kind": "function_docstring", "text": "Handler for string input as workflow entry point.\n\n        Wraps the string in a USER role ChatMessage and delegates to _handle_task_message.\n\n        Args:\n            task: Plain text task description from user\n            ctx: Workflow context\n\n        Usage:\n            workflow.run(\"Write a blog post about AI agents\")\n        ", "meta": {"scope": ["GroupChatOrchestratorExecutor", "handle_str"], "position": {"start": {"line": 531, "column": 8}, "end": {"line": 541, "column": 11}}, "target": "handle_str", "qualname": "GroupChatOrchestratorExecutor::handle_str"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_group_chat.py", "kind": "function_docstring", "text": "Handler for ChatMessage input as workflow entry point.\n\n        Directly delegates to _handle_task_message for state initialization.\n\n        Args:\n            task_message: Structured chat message from user (may include metadata, role, etc.)\n            ctx: Workflow context\n\n        Usage:\n            workflow.run(ChatMessage(role=Role.USER, text=\"Analyze this data\"))\n        ", "meta": {"scope": ["GroupChatOrchestratorExecutor", "handle_chat_message"], "position": {"start": {"line": 550, "column": 8}, "end": {"line": 560, "column": 11}}, "target": "handle_chat_message", "qualname": "GroupChatOrchestratorExecutor::handle_chat_message"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_group_chat.py", "kind": "function_docstring", "text": "Handler for conversation history as workflow entry point.\n\n        Accepts a pre-existing conversation and uses the first message in the list as the task.\n        Preserves the full conversation for state initialization.\n\n        Args:\n            conversation: List of chat messages (system, user, assistant)\n            ctx: Workflow context\n\n        Raises:\n            ValueError: If conversation list is empty\n\n        Behavior:\n            - Validates conversation is non-empty\n            - Clones conversation to avoid mutation\n            - Extracts task message (most recent USER message)\n            - Stashes full conversation in _pending_initial_conversation\n            - Delegates to _handle_task_message for initialization\n\n        Usage:\n            existing_messages = [\n                ChatMessage(role=Role.SYSTEM, text=\"You are an expert\"),\n                ChatMessage(role=Role.USER, text=\"Help me with this task\")\n            ]\n            workflow.run(existing_messages)\n        ", "meta": {"scope": ["GroupChatOrchestratorExecutor", "handle_conversation"], "position": {"start": {"line": 569, "column": 8}, "end": {"line": 594, "column": 11}}, "target": "handle_conversation", "qualname": "GroupChatOrchestratorExecutor::handle_conversation"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_group_chat.py", "kind": "function_docstring", "text": "Handle responses from custom participant executors.", "meta": {"scope": ["GroupChatOrchestratorExecutor", "handle_agent_response"], "position": {"start": {"line": 607, "column": 8}, "end": {"line": 607, "column": 65}}, "target": "handle_agent_response", "qualname": "GroupChatOrchestratorExecutor::handle_agent_response"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_group_chat.py", "kind": "function_docstring", "text": "Handle direct AgentExecutor responses.", "meta": {"scope": ["GroupChatOrchestratorExecutor", "handle_agent_executor_response"], "position": {"start": {"line": 616, "column": 8}, "end": {"line": 616, "column": 52}}, "target": "handle_agent_executor_response", "qualname": "GroupChatOrchestratorExecutor::handle_agent_executor_response"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_group_chat.py", "kind": "function_docstring", "text": "Default factory for creating the GroupChatOrchestratorExecutor instance.\n\n    This is the internal implementation used by GroupChatBuilder to instantiate the\n    orchestrator. It extracts participant descriptions from the wiring configuration\n    and passes them to the orchestrator for manager context.\n\n    Args:\n        wiring: Complete workflow configuration assembled by the builder\n\n    Returns:\n        Initialized GroupChatOrchestratorExecutor ready to coordinate the conversation\n\n    Behavior:\n        - Extracts participant names and descriptions for manager context\n        - Forwards manager instance, manager name, and max_rounds settings\n        - Allows orchestrator to auto-generate its executor ID\n\n    Why descriptions are extracted:\n        The manager needs participant descriptions (not full specs) to make informed\n        selection decisions. The orchestrator doesn't need participant instances directly\n        since routing is handled by the workflow graph.\n\n    Raises:\n        RuntimeError: If manager is None (should not happen when using default factory)\n    ", "meta": {"scope": ["_default_orchestrator_factory"], "position": {"start": {"line": 629, "column": 4}, "end": {"line": 653, "column": 7}}, "target": "_default_orchestrator_factory", "qualname": "_default_orchestrator_factory"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_group_chat.py", "kind": "function_docstring", "text": "Return a callable orchestrator factory, defaulting to the built-in implementation.", "meta": {"scope": ["group_chat_orchestrator"], "position": {"start": {"line": 666, "column": 4}, "end": {"line": 666, "column": 92}}, "target": "group_chat_orchestrator", "qualname": "group_chat_orchestrator"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_group_chat.py", "kind": "function_docstring", "text": "Build the workflow graph shared by group-chat style orchestrators.", "meta": {"scope": ["assemble_group_chat_workflow"], "position": {"start": {"line": 680, "column": 4}, "end": {"line": 680, "column": 76}}, "target": "assemble_group_chat_workflow", "qualname": "assemble_group_chat_workflow"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_handoff.py", "kind": "class_docstring", "text": "Fluent builder for conversational handoff workflows with coordinator and specialist agents.\n\n    The handoff pattern enables a coordinator agent to route requests to specialist agents.\n    A termination condition determines when the workflow should stop requesting input and complete.\n\n    Routing Patterns:\n\n    **Single-Tier (Default):** Only the coordinator can hand off to specialists. After any specialist\n    responds, control returns to the user for more input. This creates a cyclical flow:\n    user -> coordinator -> [optional specialist] -> user -> coordinator -> ...\n\n    **Multi-Tier (Advanced):** Specialists can hand off to other specialists using `.add_handoff()`.\n    This provides more flexibility for complex workflows but is less controllable than the single-tier\n    pattern. Users lose real-time visibility into intermediate steps during specialist-to-specialist\n    handoffs (though the full conversation history including all handoffs is preserved and can be\n    inspected afterward).\n\n\n    Key Features:\n    - **Automatic handoff detection**: The coordinator invokes a handoff tool whose\n      arguments (for example ``{\"handoff_to\": \"shipping_agent\"}``) identify the specialist to receive control.\n    - **Auto-generated tools**: By default the builder synthesizes `handoff_to_<agent>` tools for the coordinator,\n      so you don't manually define placeholder functions.\n    - **Full conversation history**: The entire conversation (including any\n      `ChatMessage.additional_properties`) is preserved and passed to each agent.\n    - **Termination control**: By default, terminates after 10 user messages. Override with\n      `.with_termination_condition(lambda conv: ...)` for custom logic (e.g., detect \"goodbye\").\n    - **Checkpointing**: Optional persistence for resumable workflows.\n\n    Usage (Single-Tier):\n\n    .. code-block:: python\n\n        from agent_framework import HandoffBuilder\n        from agent_framework.openai import OpenAIChatClient\n\n        chat_client = OpenAIChatClient()\n\n        # Create coordinator and specialist agents\n        coordinator = chat_client.create_agent(\n            instructions=(\n                \"You are a frontline support agent. Assess the user's issue and decide \"\n                \"whether to hand off to 'refund_agent' or 'shipping_agent'. When delegation is \"\n                \"required, call the matching handoff tool (for example `handoff_to_refund_agent`).\"\n            ),\n            name=\"coordinator_agent\",\n        )\n\n        refund = chat_client.create_agent(\n            instructions=\"You handle refund requests. Ask for order details and process refunds.\",\n            name=\"refund_agent\",\n        )\n\n        shipping = chat_client.create_agent(\n            instructions=\"You resolve shipping issues. Track packages and update delivery status.\",\n            name=\"shipping_agent\",\n        )\n\n        # Build the handoff workflow - default single-tier routing\n        workflow = (\n            HandoffBuilder(\n                name=\"customer_support\",\n                participants=[coordinator, refund, shipping],\n            )\n            .set_coordinator(\"coordinator_agent\")\n            .build()\n        )\n\n        # Run the workflow\n        events = await workflow.run_stream(\"My package hasn't arrived yet\")\n        async for event in events:\n            if isinstance(event, RequestInfoEvent):\n                # Request user input\n                user_response = input(\"You: \")\n                await workflow.send_response(event.data.request_id, user_response)\n\n    **Multi-Tier Routing with .add_handoff():**\n\n    .. code-block:: python\n\n        # Enable specialist-to-specialist handoffs with fluent API\n        workflow = (\n            HandoffBuilder(participants=[coordinator, replacement, delivery, billing])\n            .set_coordinator(\"coordinator_agent\")\n            .add_handoff(coordinator, [replacement, delivery, billing])  # Coordinator routes to all\n            .add_handoff(replacement, [delivery, billing])  # Replacement delegates to delivery/billing\n            .add_handoff(delivery, billing)  # Delivery escalates to billing\n            .build()\n        )\n\n        # Flow: User → Coordinator → Replacement → Delivery → Back to User\n        # (Replacement hands off to Delivery without returning to user)\n\n    **Custom Termination Condition:**\n\n    .. code-block:: python\n\n        # Terminate when user says goodbye or after 5 exchanges\n        workflow = (\n            HandoffBuilder(participants=[coordinator, refund, shipping])\n            .set_coordinator(\"coordinator_agent\")\n            .with_termination_condition(\n                lambda conv: sum(1 for msg in conv if msg.role.value == \"user\") >= 5\n                or any(\"goodbye\" in msg.text.lower() for msg in conv[-2:])\n            )\n            .build()\n        )\n\n    **Checkpointing:**\n\n    .. code-block:: python\n\n        from agent_framework import InMemoryCheckpointStorage\n\n        storage = InMemoryCheckpointStorage()\n        workflow = (\n            HandoffBuilder(participants=[coordinator, refund, shipping])\n            .set_coordinator(\"coordinator_agent\")\n            .with_checkpointing(storage)\n            .build()\n        )\n\n    Args:\n        name: Optional workflow name for identification and logging.\n        participants: List of agents (AgentProtocol) or executors to participate in the handoff.\n                     The first agent you specify as coordinator becomes the orchestrating agent.\n        description: Optional human-readable description of the workflow.\n\n    Raises:\n        ValueError: If participants list is empty, contains duplicates, or coordinator not specified.\n        TypeError: If participants are not AgentProtocol or Executor instances.\n    ", "meta": {"scope": ["HandoffBuilder"], "position": {"start": {"line": 560, "column": 4}, "end": {"line": 691, "column": 7}}, "target": "HandoffBuilder", "qualname": "HandoffBuilder"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_handoff.py", "kind": "function_docstring", "text": "Initialize a HandoffBuilder for creating conversational handoff workflows.\n\n        The builder starts in an unconfigured state and requires you to call:\n        1. `.participants([...])` - Register agents\n        2. `.set_coordinator(...)` - Designate which agent receives initial user input\n        3. `.build()` - Construct the final Workflow\n\n        Optional configuration methods allow you to customize context management,\n        termination logic, and persistence.\n\n        Args:\n            name: Optional workflow identifier used in logging and debugging.\n                 If not provided, a default name will be generated.\n            participants: Optional list of agents (AgentProtocol) or executors that will\n                         participate in the handoff workflow. You can also call\n                         `.participants([...])` later. Each participant must have a\n                         unique identifier (name for agents, id for executors).\n            description: Optional human-readable description explaining the workflow's\n                        purpose. Useful for documentation and observability.\n\n        Note:\n            Participants must have stable names/ids because the workflow maps the\n            handoff tool arguments to these identifiers. Agent names should match\n            the strings emitted by the coordinator's handoff tool (e.g., a tool that\n            outputs ``{\\\"handoff_to\\\": \\\"billing\\\"}`` requires an agent named ``billing``).\n        ", "meta": {"scope": ["HandoffBuilder", "__init__"], "position": {"start": {"line": 700, "column": 8}, "end": {"line": 725, "column": 11}}, "target": "__init__", "qualname": "HandoffBuilder::__init__"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_handoff.py", "kind": "comment", "text": "Termination condition", "meta": {"scope": ["HandoffBuilder", "__init__"], "position": {"start": {"line": 733, "column": 8}, "end": {"line": 733, "column": 31}}, "comment_type": "block", "line_count": 1, "original_block": "        # Termination condition\n", "qualname": "HandoffBuilder::__init__"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_handoff.py", "kind": "comment", "text": "Maps agent_id -> [target_agent_ids]", "meta": {"scope": ["HandoffBuilder", "__init__"], "position": {"start": {"line": 738, "column": 57}, "end": {"line": 738, "column": 94}}, "comment_type": "inline", "original_line": "        self._handoff_config: dict[str, list[str]] = {}  # Maps agent_id -> [target_agent_ids]\n", "qualname": "HandoffBuilder::__init__"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_handoff.py", "kind": "function_docstring", "text": "Register the agents or executors that will participate in the handoff workflow.\n\n        Each participant must have a unique identifier (name for agents, id for executors).\n        The workflow will automatically create an alias map so agents can be referenced by\n        their name, display_name, or executor id when routing.\n\n        Args:\n            participants: Sequence of AgentProtocol or Executor instances. Each must have\n                         a unique identifier. For agents, the name attribute is used as the\n                         primary identifier and must match handoff target strings.\n\n        Returns:\n            Self for method chaining.\n\n        Raises:\n            ValueError: If participants is empty or contains duplicates.\n            TypeError: If participants are not AgentProtocol or Executor instances.\n\n        Example:\n\n        .. code-block:: python\n\n            from agent_framework import HandoffBuilder\n            from agent_framework.openai import OpenAIChatClient\n\n            client = OpenAIChatClient()\n            coordinator = client.create_agent(instructions=\"...\", name=\"coordinator\")\n            refund = client.create_agent(instructions=\"...\", name=\"refund_agent\")\n            billing = client.create_agent(instructions=\"...\", name=\"billing_agent\")\n\n            builder = HandoffBuilder().participants([coordinator, refund, billing])\n            # Now you can call .set_coordinator() to designate the entry point\n\n        Note:\n            This method resets any previously configured coordinator, so you must call\n            `.set_coordinator(...)` again after changing participants.\n        ", "meta": {"scope": ["HandoffBuilder", "participants"], "position": {"start": {"line": 744, "column": 8}, "end": {"line": 780, "column": 11}}, "target": "participants", "qualname": "HandoffBuilder::participants"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_handoff.py", "kind": "function_docstring", "text": "Designate which agent receives initial user input and orchestrates specialist routing.\n\n        The coordinator agent is responsible for analyzing user requests and deciding whether to:\n        1. Handle the request directly and respond to the user, OR\n        2. Hand off to a specialist agent by including handoff metadata in the response\n\n        After a specialist responds, the workflow automatically returns control to the user,\n        creating a cyclical flow: user -> coordinator -> [specialist] -> user -> ...\n\n        Args:\n            agent: The agent to use as the coordinator. Can be:\n                  - Agent name (str): e.g., \"coordinator_agent\"\n                  - AgentProtocol instance: The actual agent object\n                  - Executor instance: A custom executor wrapping an agent\n\n        Returns:\n            Self for method chaining.\n\n        Raises:\n            ValueError: If participants(...) hasn't been called yet, or if the specified\n                       agent is not in the participants list.\n\n        Example:\n\n        .. code-block:: python\n\n            # Use agent name\n            builder = HandoffBuilder().participants([coordinator, refund, billing]).set_coordinator(\"coordinator\")\n\n            # Or pass the agent object directly\n            builder = HandoffBuilder().participants([coordinator, refund, billing]).set_coordinator(coordinator)\n\n        Note:\n            The coordinator determines routing by invoking a handoff tool call whose\n            arguments identify the target specialist (for example ``{\\\"handoff_to\\\": \\\"billing\\\"}``).\n            Decorate the tool with ``approval_mode=\"always_require\"`` to ensure the workflow\n            intercepts the call before execution and can make the transition.\n        ", "meta": {"scope": ["HandoffBuilder", "set_coordinator"], "position": {"start": {"line": 823, "column": 8}, "end": {"line": 860, "column": 11}}, "target": "set_coordinator", "qualname": "HandoffBuilder::set_coordinator"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_magentic.py", "kind": "function_docstring", "text": "Add participant agents or executors to the Magentic workflow.\n\n        Participants are the agents that will execute tasks under the manager's direction.\n        Each participant should have distinct capabilities that complement the team. The\n        manager will select which participant to invoke based on the current plan and\n        progress state.\n\n        Args:\n            **participants: Named agents or executors to add to the workflow. Names should\n                be descriptive of the agent's role (e.g., researcher=research_agent).\n                Accepts BaseAgent instances or custom Executor implementations.\n\n        Returns:\n            Self for method chaining\n\n        Usage:\n\n        .. code-block:: python\n\n            workflow = (\n                MagenticBuilder()\n                .participants(\n                    researcher=research_agent, writer=writing_agent, coder=coding_agent, reviewer=review_agent\n                )\n                .with_standard_manager(chat_client=client)\n                .build()\n            )\n\n        Notes:\n            - Participant names become part of the manager's context for selection\n            - Agent descriptions (if available) are extracted and provided to the manager\n            - Can be called multiple times to add participants incrementally\n        ", "meta": {"scope": ["MagenticBuilder", "participants"], "position": {"start": {"line": 1948, "column": 8}, "end": {"line": 1980, "column": 11}}, "target": "participants", "qualname": "MagenticBuilder::participants"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_magentic.py", "kind": "function_docstring", "text": "Enable or disable human-in-the-loop plan review before task execution.\n\n        When enabled, the workflow will pause after the manager generates the initial\n        plan and emit a _MagenticPlanReviewRequest event. A human reviewer can then\n        approve, request revisions, or reject the plan. The workflow continues only\n        after approval.\n\n        This is useful for:\n        - High-stakes tasks requiring human oversight\n        - Validating the manager's understanding of requirements\n        - Catching hallucinations or unrealistic plans early\n        - Educational scenarios where learners review AI planning\n\n        Args:\n            enable: Whether to require plan review (default True)\n\n        Returns:\n            Self for method chaining\n\n        Usage:\n\n        .. code-block:: python\n\n            workflow = (\n                MagenticBuilder()\n                .participants(agent1=agent1)\n                .with_standard_manager(chat_client=client)\n                .with_plan_review(enable=True)\n                .build()\n            )\n\n            # During execution, handle plan review\n            async for event in workflow.run_stream(\"task\"):\n                if isinstance(event, _MagenticPlanReviewRequest):\n                    # Review plan and respond\n                    reply = _MagenticPlanReviewReply(decision=MagenticPlanReviewDecision.APPROVE)\n                    await workflow.send(reply)\n\n        See Also:\n            - :class:`_MagenticPlanReviewRequest`: Event emitted for review\n            - :class:`_MagenticPlanReviewReply`: Response to send back\n            - :class:`MagenticPlanReviewDecision`: Approve/Revise/Reject options\n        ", "meta": {"scope": ["MagenticBuilder", "with_plan_review"], "position": {"start": {"line": 1985, "column": 8}, "end": {"line": 2027, "column": 11}}, "target": "with_plan_review", "qualname": "MagenticBuilder::with_plan_review"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_magentic.py", "kind": "function_docstring", "text": "Enable workflow state persistence using the provided checkpoint storage.\n\n        Checkpointing allows workflows to be paused, resumed across process restarts,\n        or recovered after failures. The entire workflow state including conversation\n        history, task ledgers, and progress is persisted at key points.\n\n        Args:\n            checkpoint_storage: Storage backend for checkpoints (e.g., InMemoryCheckpointStorage,\n                FileCheckpointStorage, or custom implementations)\n\n        Returns:\n            Self for method chaining\n\n        Usage:\n\n        .. code-block:: python\n\n            from agent_framework import InMemoryCheckpointStorage\n\n            storage = InMemoryCheckpointStorage()\n            workflow = (\n                MagenticBuilder()\n                .participants(agent1=agent1)\n                .with_standard_manager(chat_client=client)\n                .with_checkpointing(storage)\n                .build()\n            )\n\n            # First run\n            thread_id = \"task-123\"\n            async for msg in workflow.run(\"task\", thread_id=thread_id):\n                print(msg.text)\n\n            # Resume from checkpoint\n            async for msg in workflow.run(\"continue\", thread_id=thread_id):\n                print(msg.text)\n\n        Notes:\n            - Checkpoints are created after each significant state transition\n            - Thread ID must be consistent across runs to resume properly\n            - Storage implementations may have different persistence guarantees\n        ", "meta": {"scope": ["MagenticBuilder", "with_checkpointing"], "position": {"start": {"line": 2032, "column": 8}, "end": {"line": 2073, "column": 11}}, "target": "with_checkpointing", "qualname": "MagenticBuilder::with_checkpointing"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_magentic.py", "kind": "function_docstring", "text": "Configure the workflow manager for task planning and agent coordination.\n\n        The manager is responsible for creating plans, selecting agents, tracking progress,\n        and deciding when to replan or complete. This method supports two usage patterns:\n\n        1. **Provide existing manager**: Pass a pre-configured manager instance (custom\n           or standard) for full control over behavior\n        2. **Auto-create standard manager**: Pass chat_client and options to automatically\n           create a StandardMagenticManager with specified configuration\n\n        Args:\n            manager: Pre-configured manager instance (StandardMagenticManager or custom\n                MagenticManagerBase subclass). If provided, all other arguments are ignored.\n            chat_client: LLM chat client for generating plans and decisions. Required if\n                manager is not provided.\n            task_ledger: Optional custom task ledger implementation for specialized\n                prompting or structured output requirements\n            instructions: System instructions prepended to all manager prompts to guide\n                behavior and set expectations\n            task_ledger_facts_prompt: Custom prompt template for extracting facts from\n                task description\n            task_ledger_plan_prompt: Custom prompt template for generating initial plan\n            task_ledger_full_prompt: Custom prompt template for complete task ledger\n                (facts + plan combined)\n            task_ledger_facts_update_prompt: Custom prompt template for updating facts\n                based on agent progress\n            task_ledger_plan_update_prompt: Custom prompt template for replanning when\n                needed\n            progress_ledger_prompt: Custom prompt template for assessing progress and\n                determining next actions\n            final_answer_prompt: Custom prompt template for synthesizing final response\n                when task is complete\n            max_stall_count: Maximum consecutive rounds without progress before triggering\n                replan (default 3). Set to 0 to disable stall detection.\n            max_reset_count: Maximum number of complete resets allowed before failing.\n                None means unlimited resets.\n            max_round_count: Maximum total coordination rounds before stopping with\n                partial result. None means unlimited rounds.\n\n        Returns:\n            Self for method chaining\n\n        Raises:\n            ValueError: If manager is None and chat_client is also None\n\n        Usage with auto-created manager:\n\n        .. code-block:: python\n\n            from azure.ai.projects.aio import AIProjectClient\n\n            project_client = AIProjectClient.from_connection_string(...)\n            chat_client = project_client.inference.get_chat_completions_client()\n\n            workflow = (\n                MagenticBuilder()\n                .participants(agent1=agent1, agent2=agent2)\n                .with_standard_manager(\n                    chat_client=chat_client,\n                    max_round_count=20,\n                    max_stall_count=3,\n                    instructions=\"Be concise and focus on accuracy\",\n                )\n                .build()\n            )\n\n        Usage with custom manager:\n\n        .. code-block:: python\n\n            class MyManager(MagenticManagerBase):\n                async def plan(self, context: MagenticContext) -> ChatMessage:\n                    # Custom planning logic\n                    return ChatMessage(role=Role.ASSISTANT, text=\"...\")\n\n\n            manager = MyManager()\n            workflow = MagenticBuilder().participants(agent1=agent1).with_standard_manager(manager).build()\n\n        Usage with prompt customization:\n\n        .. code-block:: python\n\n            workflow = (\n                MagenticBuilder()\n                .participants(coder=coder_agent, reviewer=reviewer_agent)\n                .with_standard_manager(\n                    chat_client=chat_client,\n                    task_ledger_plan_prompt=\"Create a detailed step-by-step plan...\",\n                    progress_ledger_prompt=\"Assess progress and decide next action...\",\n                    max_stall_count=2,\n                )\n                .build()\n            )\n\n        Notes:\n            - StandardMagenticManager uses structured LLM calls for all decisions\n            - Custom managers can implement alternative selection strategies\n            - Prompt templates support Jinja2-style variable substitution\n            - Stall detection helps prevent infinite loops in stuck scenarios\n        ", "meta": {"scope": ["MagenticBuilder", "with_standard_manager"], "position": {"start": {"line": 2098, "column": 8}, "end": {"line": 2198, "column": 11}}, "target": "with_standard_manager", "qualname": "MagenticBuilder::with_standard_manager"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_magentic.py", "kind": "comment", "text": "Constructor args for StandardMagenticManager when manager is not provided", "meta": {"scope": ["MagenticBuilder", "with_standard_manager"], "position": {"start": {"line": 2081, "column": 8}, "end": {"line": 2081, "column": 83}}, "comment_type": "block", "line_count": 1, "original_block": "        # Constructor args for StandardMagenticManager when manager is not provided\n", "qualname": "MagenticBuilder::with_standard_manager"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_magentic.py", "kind": "comment", "text": "Prompt overrides", "meta": {"scope": ["MagenticBuilder", "with_standard_manager"], "position": {"start": {"line": 2085, "column": 8}, "end": {"line": 2085, "column": 26}}, "comment_type": "block", "line_count": 1, "original_block": "        # Prompt overrides\n", "qualname": "MagenticBuilder::with_standard_manager"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_magentic.py", "kind": "comment", "text": "Limits", "meta": {"scope": ["MagenticBuilder", "with_standard_manager"], "position": {"start": {"line": 2093, "column": 8}, "end": {"line": 2093, "column": 16}}, "comment_type": "block", "line_count": 1, "original_block": "        # Limits\n", "qualname": "MagenticBuilder::with_standard_manager"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_magentic.py", "kind": "function_docstring", "text": "Build a Magentic workflow with the orchestrator and all agent executors.", "meta": {"scope": ["MagenticBuilder", "build"], "position": {"start": {"line": 2226, "column": 8}, "end": {"line": 2226, "column": 86}}, "target": "build", "qualname": "MagenticBuilder::build"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_magentic.py", "kind": "comment", "text": "Create participant descriptions", "meta": {"scope": ["MagenticBuilder", "build"], "position": {"start": {"line": 2235, "column": 8}, "end": {"line": 2235, "column": 41}}, "comment_type": "block", "line_count": 1, "original_block": "        # Create participant descriptions\n", "qualname": "MagenticBuilder::build"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_magentic.py", "kind": "comment", "text": "Type narrowing: we already checked self._manager is not None above", "meta": {"scope": ["MagenticBuilder", "build"], "position": {"start": {"line": 2241, "column": 8}, "end": {"line": 2241, "column": 76}}, "comment_type": "block", "line_count": 1, "original_block": "        # Type narrowing: we already checked self._manager is not None above\n", "qualname": "MagenticBuilder::build"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_magentic.py", "kind": "comment", "text": "Magentic provides its own orchestrator via custom factory, so no manager is needed", "meta": {"scope": ["MagenticBuilder", "build"], "position": {"start": {"line": 2265, "column": 8}, "end": {"line": 2265, "column": 92}}, "comment_type": "block", "line_count": 1, "original_block": "        # Magentic provides its own orchestrator via custom factory, so no manager is needed\n", "qualname": "MagenticBuilder::build"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_magentic.py", "kind": "function_docstring", "text": "Build a Magentic workflow and return a wrapper with convenience methods for string tasks.\n\n        Args:\n            task: The task description as a string.\n\n        Returns:\n            A MagenticWorkflow wrapper that provides convenience methods for starting with strings.\n        ", "meta": {"scope": ["MagenticBuilder", "start_with_string"], "position": {"start": {"line": 2283, "column": 8}, "end": {"line": 2290, "column": 11}}, "target": "start_with_string", "qualname": "MagenticBuilder::start_with_string"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_magentic.py", "kind": "function_docstring", "text": "Build a Magentic workflow and return a wrapper with convenience methods for ChatMessage tasks.\n\n        Args:\n            task: The task as a ChatMessage.\n\n        Returns:\n            A MagenticWorkflow wrapper that provides convenience methods.\n        ", "meta": {"scope": ["MagenticBuilder", "start_with_message"], "position": {"start": {"line": 2294, "column": 8}, "end": {"line": 2301, "column": 11}}, "target": "start_with_message", "qualname": "MagenticBuilder::start_with_message"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_magentic.py", "kind": "function_docstring", "text": "Build a Magentic workflow and return a wrapper with convenience methods.\n\n        Args:\n            task: The task description as a string or ChatMessage.\n\n        Returns:\n            A MagenticWorkflow wrapper that provides convenience methods.\n        ", "meta": {"scope": ["MagenticBuilder", "start_with"], "position": {"start": {"line": 2305, "column": 8}, "end": {"line": 2312, "column": 11}}, "target": "start_with", "qualname": "MagenticBuilder::start_with"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_magentic.py", "kind": "class_docstring", "text": "A wrapper around the base Workflow that provides convenience methods for Magentic workflows.", "meta": {"scope": ["MagenticWorkflow"], "position": {"start": {"line": 2325, "column": 4}, "end": {"line": 2325, "column": 102}}, "target": "MagenticWorkflow", "qualname": "MagenticWorkflow"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_magentic.py", "kind": "comment", "text": "endregion Magentic Workflow Builder\nregion Magentic Workflow", "meta": {"scope": ["MagenticWorkflow"], "position": {"start": {"line": 2318, "column": 0}, "end": {"line": 2321, "column": 26}}, "comment_type": "block", "line_count": 2, "original_block": "# endregion Magentic Workflow Builder\n\n\n# region Magentic Workflow\n", "qualname": "MagenticWorkflow"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_magentic.py", "kind": "function_docstring", "text": "Access the underlying workflow.", "meta": {"scope": ["MagenticWorkflow", "workflow"], "position": {"start": {"line": 2333, "column": 8}, "end": {"line": 2333, "column": 45}}, "target": "workflow", "qualname": "MagenticWorkflow::workflow"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_magentic.py", "kind": "function_docstring", "text": "Run the workflow with a task string.\n\n        Args:\n            task_text: The task description as a string.\n\n        Yields:\n            WorkflowEvent: The events generated during the workflow execution.\n        ", "meta": {"scope": ["MagenticWorkflow", "run_streaming_with_string"], "position": {"start": {"line": 2337, "column": 8}, "end": {"line": 2344, "column": 11}}, "target": "run_streaming_with_string", "qualname": "MagenticWorkflow::run_streaming_with_string"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_magentic.py", "kind": "function_docstring", "text": "Run the workflow with a ChatMessage.\n\n        Args:\n            task_message: The task as a ChatMessage.\n\n        Yields:\n            WorkflowEvent: The events generated during the workflow execution.\n        ", "meta": {"scope": ["MagenticWorkflow", "run_streaming_with_message"], "position": {"start": {"line": 2350, "column": 8}, "end": {"line": 2357, "column": 11}}, "target": "run_streaming_with_message", "qualname": "MagenticWorkflow::run_streaming_with_message"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_magentic.py", "kind": "function_docstring", "text": "Run the workflow with either a message object or the preset task string.\n\n        Args:\n            message: The message to send. If None and task_text was provided during construction,\n                    uses the preset task string.\n\n        Yields:\n            WorkflowEvent: The events generated during the workflow execution.\n        ", "meta": {"scope": ["MagenticWorkflow", "run_stream"], "position": {"start": {"line": 2363, "column": 8}, "end": {"line": 2371, "column": 11}}, "target": "run_stream", "qualname": "MagenticWorkflow::run_stream"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_magentic.py", "kind": "function_docstring", "text": "Ensure participant roster matches the checkpoint before attempting restoration.", "meta": {"scope": ["MagenticWorkflow", "_validate_checkpoint_participants"], "position": {"start": {"line": 2389, "column": 8}, "end": {"line": 2389, "column": 93}}, "target": "_validate_checkpoint_participants", "qualname": "MagenticWorkflow::_validate_checkpoint_participants"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_magentic.py", "kind": "comment", "text": "At this point, checkpoint is guaranteed to be WorkflowCheckpoint", "meta": {"scope": ["MagenticWorkflow", "_validate_checkpoint_participants"], "position": {"start": {"line": 2427, "column": 8}, "end": {"line": 2427, "column": 74}}, "comment_type": "block", "line_count": 1, "original_block": "        # At this point, checkpoint is guaranteed to be WorkflowCheckpoint\n", "qualname": "MagenticWorkflow::_validate_checkpoint_participants"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_magentic.py", "kind": "function_docstring", "text": "Resume orchestration from a checkpoint and stream resulting events.", "meta": {"scope": ["MagenticWorkflow", "run_stream_from_checkpoint"], "position": {"start": {"line": 2467, "column": 8}, "end": {"line": 2467, "column": 81}}, "target": "run_stream_from_checkpoint", "qualname": "MagenticWorkflow::run_stream_from_checkpoint"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow.py", "kind": "class_docstring", "text": "A graph-based execution engine that orchestrates connected executors.\n\n    ## Overview\n    A workflow executes a directed graph of executors connected via edge groups using a Pregel-like model,\n    running in supersteps until the graph becomes idle. Workflows are created using the\n    WorkflowBuilder class - do not instantiate this class directly.\n\n    ## Execution Model\n    Executors run in synchronized supersteps where each executor:\n    - Is invoked when it receives messages from connected edge groups\n    - Can send messages to downstream executors via ctx.send_message()\n    - Can yield workflow-level outputs via ctx.yield_output()\n    - Can emit custom events via ctx.add_event()\n\n    Messages between executors are delivered at the end of each superstep and are not\n    visible in the event stream. Only workflow-level events (outputs, custom events)\n    and status events are observable to callers.\n\n    ## Input/Output Types\n    Workflow types are discovered at runtime by inspecting:\n    - Input types: From the start executor's input types\n    - Output types: Union of all executors' workflow output types\n    Access these via the input_types and output_types properties.\n\n    ## Execution Methods\n    - run(): Execute to completion, returns WorkflowRunResult with all events\n    - run_stream(): Returns async generator yielding events as they occur\n    - run_from_checkpoint(): Resume from a saved checkpoint\n    - run_stream_from_checkpoint(): Resume from checkpoint with streaming\n\n    ## External Input Requests\n    Workflows can request external input using a RequestInfoExecutor:\n    1. Executor connects to RequestInfoExecutor via edge group and back to itself\n    2. Executor sends RequestInfoMessage to RequestInfoExecutor\n    3. RequestInfoExecutor emits RequestInfoEvent and workflow enters IDLE_WITH_PENDING_REQUESTS\n    4. Caller handles requests and uses send_responses()/send_responses_streaming() to continue\n\n    ## Checkpointing\n    When enabled, checkpoints are created at the end of each superstep, capturing:\n    - Executor states\n    - Messages in transit\n    - Shared state\n    Workflows can be paused and resumed across process restarts using checkpoint storage.\n\n    ## Composition\n    Workflows can be nested using WorkflowExecutor, which wraps a child workflow as an executor.\n    The nested workflow's input/output types become part of the WorkflowExecutor's types.\n    When invoked, the WorkflowExecutor runs the nested workflow to completion and processes its outputs.\n    ", "meta": {"scope": ["Workflow"], "position": {"start": {"line": 110, "column": 4}, "end": {"line": 158, "column": 7}}, "target": "Workflow", "qualname": "Workflow"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow.py", "kind": "comment", "text": "region Workflow", "meta": {"scope": ["Workflow"], "position": {"start": {"line": 106, "column": 0}, "end": {"line": 106, "column": 17}}, "comment_type": "block", "line_count": 1, "original_block": "# region Workflow\n", "qualname": "Workflow"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow.py", "kind": "function_docstring", "text": "Initialize the workflow with a list of edges.\n\n        Args:\n            edge_groups: A list of EdgeGroup instances that define the workflow edges.\n            executors: A dictionary mapping executor IDs to Executor instances.\n            start_executor: The starting executor for the workflow, which can be an Executor instance or its ID.\n            runner_context: The RunnerContext instance to be used during workflow execution.\n            max_iterations: The maximum number of iterations the workflow will run for convergence.\n            name: Optional human-readable name for the workflow.\n            description: Optional description of what the workflow does.\n            kwargs: Additional keyword arguments. Unused in this implementation.\n        ", "meta": {"scope": ["Workflow", "__init__"], "position": {"start": {"line": 171, "column": 8}, "end": {"line": 182, "column": 11}}, "target": "__init__", "qualname": "Workflow::__init__"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow.py", "kind": "comment", "text": "Convert start_executor to string ID if it's an Executor instance", "meta": {"scope": ["Workflow", "__init__"], "position": {"start": {"line": 183, "column": 8}, "end": {"line": 183, "column": 74}}, "comment_type": "block", "line_count": 1, "original_block": "        # Convert start_executor to string ID if it's an Executor instance\n", "qualname": "Workflow::__init__"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow.py", "kind": "comment", "text": "Store non-serializable runtime objects as private attributes", "meta": {"scope": ["Workflow", "__init__"], "position": {"start": {"line": 194, "column": 8}, "end": {"line": 194, "column": 70}}, "comment_type": "block", "line_count": 1, "original_block": "        # Store non-serializable runtime objects as private attributes\n", "qualname": "Workflow::__init__"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow.py", "kind": "comment", "text": "Flag to prevent concurrent workflow executions", "meta": {"scope": ["Workflow", "__init__"], "position": {"start": {"line": 206, "column": 8}, "end": {"line": 206, "column": 56}}, "comment_type": "block", "line_count": 1, "original_block": "        # Flag to prevent concurrent workflow executions\n", "qualname": "Workflow::__init__"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow.py", "kind": "comment", "text": "Capture a canonical fingerprint of the workflow graph so checkpoints\ncan assert they are resumed with an equivalent topology.", "meta": {"scope": ["Workflow", "__init__"], "position": {"start": {"line": 209, "column": 8}, "end": {"line": 210, "column": 66}}, "comment_type": "block", "line_count": 2, "original_block": "        # Capture a canonical fingerprint of the workflow graph so checkpoints\n        # can assert they are resumed with an equivalent topology.\n", "qualname": "Workflow::__init__"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow.py", "kind": "function_docstring", "text": "Ensure the workflow is not already running.", "meta": {"scope": ["Workflow", "_ensure_not_running"], "position": {"start": {"line": 216, "column": 8}, "end": {"line": 216, "column": 57}}, "target": "_ensure_not_running", "qualname": "Workflow::_ensure_not_running"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow.py", "kind": "function_docstring", "text": "Reset the running flag.", "meta": {"scope": ["Workflow", "_reset_running_flag"], "position": {"start": {"line": 222, "column": 8}, "end": {"line": 222, "column": 37}}, "target": "_reset_running_flag", "qualname": "Workflow::_reset_running_flag"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow.py", "kind": "function_docstring", "text": "Serialize the workflow definition into a JSON-ready dictionary.", "meta": {"scope": ["Workflow", "to_dict"], "position": {"start": {"line": 226, "column": 8}, "end": {"line": 226, "column": 77}}, "target": "to_dict", "qualname": "Workflow::to_dict"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow.py", "kind": "comment", "text": "Add optional name and description if provided", "meta": {"scope": ["Workflow", "to_dict"], "position": {"start": {"line": 235, "column": 8}, "end": {"line": 235, "column": 55}}, "comment_type": "block", "line_count": 1, "original_block": "        # Add optional name and description if provided\n", "qualname": "Workflow::to_dict"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow.py", "kind": "function_docstring", "text": "Serialize the workflow definition to JSON.", "meta": {"scope": ["Workflow", "to_json"], "position": {"start": {"line": 258, "column": 8}, "end": {"line": 258, "column": 56}}, "target": "to_json", "qualname": "Workflow::to_json"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow.py", "kind": "function_docstring", "text": "Get the starting executor of the workflow.\n\n        Returns:\n            The starting executor instance.\n        ", "meta": {"scope": ["Workflow", "get_start_executor"], "position": {"start": {"line": 262, "column": 8}, "end": {"line": 266, "column": 11}}, "target": "get_start_executor", "qualname": "Workflow::get_start_executor"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow.py", "kind": "function_docstring", "text": "Get the list of executors in the workflow.", "meta": {"scope": ["Workflow", "get_executors_list"], "position": {"start": {"line": 270, "column": 8}, "end": {"line": 270, "column": 56}}, "target": "get_executors_list", "qualname": "Workflow::get_executors_list"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow.py", "kind": "function_docstring", "text": "Private method to run workflow with proper tracing.\n\n        All workflow entry points create a NEW workflow span. It is the responsibility\n        of external callers to maintain context across different workflow runs.\n\n        Args:\n            initial_executor_fn: Optional function to execute initial executor\n            reset_context: Whether to reset the context for a new run\n            streaming: Whether to enable streaming mode for agents\n\n        Yields:\n            WorkflowEvent: The events generated during the workflow execution.\n        ", "meta": {"scope": ["Workflow", "_run_workflow_with_tracing"], "position": {"start": {"line": 279, "column": 8}, "end": {"line": 291, "column": 11}}, "target": "_run_workflow_with_tracing", "qualname": "Workflow::_run_workflow_with_tracing"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow.py", "kind": "comment", "text": "Create workflow span that encompasses the entire execution", "meta": {"scope": ["Workflow", "_run_workflow_with_tracing"], "position": {"start": {"line": 292, "column": 8}, "end": {"line": 292, "column": 68}}, "comment_type": "block", "line_count": 1, "original_block": "        # Create workflow span that encompasses the entire execution\n", "qualname": "Workflow::_run_workflow_with_tracing"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow.py", "kind": "comment", "text": "Add workflow started event (telemetry + surface state to consumers)", "meta": {"scope": ["Workflow", "_run_workflow_with_tracing"], "position": {"start": {"line": 306, "column": 16}, "end": {"line": 306, "column": 85}}, "comment_type": "block", "line_count": 1, "original_block": "                # Add workflow started event (telemetry + surface state to consumers)\n", "qualname": "Workflow::_run_workflow_with_tracing"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow.py", "kind": "comment", "text": "Emit explicit start/status events to the stream", "meta": {"scope": ["Workflow", "_run_workflow_with_tracing"], "position": {"start": {"line": 308, "column": 16}, "end": {"line": 308, "column": 65}}, "comment_type": "block", "line_count": 1, "original_block": "                # Emit explicit start/status events to the stream\n", "qualname": "Workflow::_run_workflow_with_tracing"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow.py", "kind": "comment", "text": "Reset context for a new run if supported", "meta": {"scope": ["Workflow", "_run_workflow_with_tracing"], "position": {"start": {"line": 316, "column": 16}, "end": {"line": 316, "column": 58}}, "comment_type": "block", "line_count": 1, "original_block": "                # Reset context for a new run if supported\n", "qualname": "Workflow::_run_workflow_with_tracing"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow.py", "kind": "comment", "text": "Set streaming mode after reset", "meta": {"scope": ["Workflow", "_run_workflow_with_tracing"], "position": {"start": {"line": 322, "column": 16}, "end": {"line": 322, "column": 48}}, "comment_type": "block", "line_count": 1, "original_block": "                # Set streaming mode after reset\n", "qualname": "Workflow::_run_workflow_with_tracing"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow.py", "kind": "comment", "text": "Execute initial setup if provided", "meta": {"scope": ["Workflow", "_run_workflow_with_tracing"], "position": {"start": {"line": 325, "column": 16}, "end": {"line": 325, "column": 51}}, "comment_type": "block", "line_count": 1, "original_block": "                # Execute initial setup if provided\n", "qualname": "Workflow::_run_workflow_with_tracing"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow.py", "kind": "comment", "text": "All executor executions happen within workflow span", "meta": {"scope": ["Workflow", "_run_workflow_with_tracing"], "position": {"start": {"line": 329, "column": 16}, "end": {"line": 329, "column": 69}}, "comment_type": "block", "line_count": 1, "original_block": "                # All executor executions happen within workflow span\n", "qualname": "Workflow::_run_workflow_with_tracing"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow.py", "kind": "comment", "text": "Track request events for final status determination", "meta": {"scope": ["Workflow", "_run_workflow_with_tracing"], "position": {"start": {"line": 331, "column": 20}, "end": {"line": 331, "column": 73}}, "comment_type": "block", "line_count": 1, "original_block": "                    # Track request events for final status determination\n", "qualname": "Workflow::_run_workflow_with_tracing"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow.py", "kind": "comment", "text": "Workflow runs until idle - emit final status based on whether requests are pending", "meta": {"scope": ["Workflow", "_run_workflow_with_tracing"], "position": {"start": {"line": 342, "column": 16}, "end": {"line": 342, "column": 100}}, "comment_type": "block", "line_count": 1, "original_block": "                # Workflow runs until idle - emit final status based on whether requests are pending\n", "qualname": "Workflow::_run_workflow_with_tracing"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow.py", "kind": "comment", "text": "Surface structured failure details before propagating exception", "meta": {"scope": ["Workflow", "_run_workflow_with_tracing"], "position": {"start": {"line": 354, "column": 16}, "end": {"line": 354, "column": 81}}, "comment_type": "block", "line_count": 1, "original_block": "                # Surface structured failure details before propagating exception\n", "qualname": "Workflow::_run_workflow_with_tracing"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow.py", "kind": "function_docstring", "text": "Run the workflow with a starting message and stream events.\n\n        Args:\n            message: The message to be sent to the starting executor.\n\n        Yields:\n            WorkflowEvent: The events generated during the workflow execution.\n        ", "meta": {"scope": ["Workflow", "run_stream"], "position": {"start": {"line": 373, "column": 8}, "end": {"line": 380, "column": 11}}, "target": "run_stream", "qualname": "Workflow::run_stream"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow.py", "kind": "function_docstring", "text": "Resume workflow execution from a checkpoint and stream events.\n\n        Args:\n            checkpoint_id: The ID of the checkpoint to restore from.\n            checkpoint_storage: Optional checkpoint storage to use for restoration.\n                              If not provided, the workflow must have been built with checkpointing enabled.\n            responses: Optional dictionary of responses to inject into the workflow\n                      after restoration. Keys are request IDs, values are response data.\n\n        Yields:\n            WorkflowEvent: Events generated during workflow execution.\n\n        Raises:\n            ValueError: If neither checkpoint_storage is provided nor checkpointing is enabled.\n            RuntimeError: If checkpoint restoration fails.\n        ", "meta": {"scope": ["Workflow", "run_stream_from_checkpoint"], "position": {"start": {"line": 408, "column": 8}, "end": {"line": 423, "column": 11}}, "target": "run_stream_from_checkpoint", "qualname": "Workflow::run_stream_from_checkpoint"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow.py", "kind": "comment", "text": "Process any pending messages from the checkpoint first\nThis ensures that RequestInfoExecutor state is properly populated\nbefore we try to handle responses", "meta": {"scope": ["Workflow", "run_stream_from_checkpoint", "checkpoint_restoration"], "position": {"start": {"line": 441, "column": 16}, "end": {"line": 443, "column": 51}}, "comment_type": "block", "line_count": 3, "original_block": "                # Process any pending messages from the checkpoint first\n                # This ensures that RequestInfoExecutor state is properly populated\n                # before we try to handle responses\n", "qualname": "Workflow::run_stream_from_checkpoint::checkpoint_restoration"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow.py", "kind": "comment", "text": "Run one iteration to process pending messages\nThis will populate RequestInfoExecutor._request_events properly", "meta": {"scope": ["Workflow", "run_stream_from_checkpoint", "checkpoint_restoration"], "position": {"start": {"line": 445, "column": 20}, "end": {"line": 446, "column": 85}}, "comment_type": "block", "line_count": 2, "original_block": "                    # Run one iteration to process pending messages\n                    # This will populate RequestInfoExecutor._request_events properly\n", "qualname": "Workflow::run_stream_from_checkpoint::checkpoint_restoration"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow.py", "kind": "function_docstring", "text": "Send responses back to the workflow and stream the events generated by the workflow.\n\n        Args:\n            responses: The responses to be sent back to the workflow, where keys are request IDs\n                       and values are the corresponding response data.\n\n        Yields:\n            WorkflowEvent: The events generated during the workflow execution after sending the responses.\n        ", "meta": {"scope": ["Workflow", "send_responses_streaming"], "position": {"start": {"line": 485, "column": 8}, "end": {"line": 493, "column": 11}}, "target": "send_responses_streaming", "qualname": "Workflow::send_responses_streaming"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow.py", "kind": "function_docstring", "text": "Handle the response from the RequestInfoExecutor.", "meta": {"scope": ["Workflow", "send_responses_streaming", "send_responses", "_handle_response"], "position": {"start": {"line": 503, "column": 20}, "end": {"line": 503, "column": 75}}, "target": "_handle_response", "qualname": "Workflow::send_responses_streaming::send_responses::_handle_response"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow.py", "kind": "function_docstring", "text": "Run the workflow with the given message.\n\n        Args:\n            message: The message to be processed by the workflow.\n            include_status_events: Whether to include WorkflowStatusEvent instances in the result list.\n\n        Returns:\n            A WorkflowRunResult instance containing a list of events generated during the workflow execution.\n        ", "meta": {"scope": ["Workflow", "run"], "position": {"start": {"line": 531, "column": 8}, "end": {"line": 539, "column": 11}}, "target": "run", "qualname": "Workflow::run"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow.py", "kind": "comment", "text": "Filter events for non-streaming mode", "meta": {"scope": ["Workflow", "run"], "position": {"start": {"line": 564, "column": 8}, "end": {"line": 564, "column": 46}}, "comment_type": "block", "line_count": 1, "original_block": "        # Filter events for non-streaming mode\n", "qualname": "Workflow::run"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow.py", "kind": "comment", "text": "Omit WorkflowStartedEvent from non-streaming (telemetry-only)", "meta": {"scope": ["Workflow", "run"], "position": {"start": {"line": 569, "column": 12}, "end": {"line": 569, "column": 75}}, "comment_type": "block", "line_count": 1, "original_block": "            # Omit WorkflowStartedEvent from non-streaming (telemetry-only)\n", "qualname": "Workflow::run"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow.py", "kind": "comment", "text": "Track status; include inline only if explicitly requested", "meta": {"scope": ["Workflow", "run"], "position": {"start": {"line": 572, "column": 12}, "end": {"line": 572, "column": 71}}, "comment_type": "block", "line_count": 1, "original_block": "            # Track status; include inline only if explicitly requested\n", "qualname": "Workflow::run"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow.py", "kind": "function_docstring", "text": "Resume workflow execution from a checkpoint.\n\n        Args:\n            checkpoint_id: The ID of the checkpoint to restore from.\n            checkpoint_storage: Optional checkpoint storage to use for restoration.\n                              If not provided, the workflow must have been built with checkpointing enabled.\n            responses: Optional dictionary of responses to inject into the workflow\n                      after restoration. Keys are request IDs, values are response data.\n\n        Returns:\n            A WorkflowRunResult instance containing a list of events generated during the workflow execution.\n\n        Raises:\n            ValueError: If neither checkpoint_storage is provided nor checkpointing is enabled.\n            RuntimeError: If checkpoint restoration fails.\n        ", "meta": {"scope": ["Workflow", "run_from_checkpoint"], "position": {"start": {"line": 588, "column": 8}, "end": {"line": 603, "column": 11}}, "target": "run_from_checkpoint", "qualname": "Workflow::run_from_checkpoint"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow.py", "kind": "comment", "text": "Process any pending messages from the checkpoint first\nThis ensures that RequestInfoExecutor state is properly populated\nbefore we try to handle responses", "meta": {"scope": ["Workflow", "run_from_checkpoint", "checkpoint_restoration"], "position": {"start": {"line": 621, "column": 16}, "end": {"line": 623, "column": 51}}, "comment_type": "block", "line_count": 3, "original_block": "                # Process any pending messages from the checkpoint first\n                # This ensures that RequestInfoExecutor state is properly populated\n                # before we try to handle responses\n", "qualname": "Workflow::run_from_checkpoint::checkpoint_restoration"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow.py", "kind": "comment", "text": "Run one iteration to process pending messages\nThis will populate RequestInfoExecutor._request_events properly", "meta": {"scope": ["Workflow", "run_from_checkpoint", "checkpoint_restoration"], "position": {"start": {"line": 625, "column": 20}, "end": {"line": 626, "column": 85}}, "comment_type": "block", "line_count": 2, "original_block": "                    # Run one iteration to process pending messages\n                    # This will populate RequestInfoExecutor._request_events properly\n", "qualname": "Workflow::run_from_checkpoint::checkpoint_restoration"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow.py", "kind": "function_docstring", "text": "Send responses back to the workflow.\n\n        Args:\n            responses: A dictionary where keys are request IDs and values are the corresponding response data.\n\n        Returns:\n            A WorkflowRunResult instance containing a list of events generated during the workflow execution.\n        ", "meta": {"scope": ["Workflow", "send_responses"], "position": {"start": {"line": 669, "column": 8}, "end": {"line": 676, "column": 11}}, "target": "send_responses", "qualname": "Workflow::send_responses"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow.py", "kind": "function_docstring", "text": "Handle the response from the RequestInfoExecutor.", "meta": {"scope": ["Workflow", "send_responses", "send_responses_internal", "_handle_response"], "position": {"start": {"line": 686, "column": 20}, "end": {"line": 686, "column": 75}}, "target": "_handle_response", "qualname": "Workflow::send_responses::send_responses_internal::_handle_response"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow.py", "kind": "function_docstring", "text": "Get an executor by its ID.\n\n        Args:\n            executor_id: The ID of the executor to retrieve.\n\n        Returns:\n            The Executor instance corresponding to the given ID.\n        ", "meta": {"scope": ["Workflow", "_get_executor_by_id"], "position": {"start": {"line": 718, "column": 8}, "end": {"line": 725, "column": 11}}, "target": "_get_executor_by_id", "qualname": "Workflow::_get_executor_by_id"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow.py", "kind": "function_docstring", "text": "Find the RequestInfoExecutor instance in this workflow.\n\n        Returns:\n            The RequestInfoExecutor instance if found, None otherwise.\n        ", "meta": {"scope": ["Workflow", "_find_request_info_executor"], "position": {"start": {"line": 731, "column": 8}, "end": {"line": 735, "column": 11}}, "target": "_find_request_info_executor", "qualname": "Workflow::_find_request_info_executor"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow.py", "kind": "function_docstring", "text": "Build a canonical fingerprint of the workflow graph topology for checkpoint validation.\n\n        This creates a minimal, stable representation that captures only the structural\n        elements of the workflow (executor types, edge relationships, topology) while\n        ignoring data/state changes. Used to verify that a workflow's structure hasn't\n        changed when resuming from checkpoints.\n        ", "meta": {"scope": ["Workflow", "_compute_graph_signature"], "position": {"start": {"line": 746, "column": 8}, "end": {"line": 752, "column": 11}}, "target": "_compute_graph_signature", "qualname": "Workflow::_compute_graph_signature"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow.py", "kind": "comment", "text": "Graph signature helpers", "meta": {"scope": ["Workflow", "_compute_graph_signature"], "position": {"start": {"line": 743, "column": 4}, "end": {"line": 743, "column": 29}}, "comment_type": "block", "line_count": 1, "original_block": "    # Graph signature helpers\n", "qualname": "Workflow::_compute_graph_signature"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow.py", "kind": "function_docstring", "text": "Get the input types of the workflow.\n\n        The input types are the list of input types of the start executor.\n\n        Returns:\n            A list of input types that the workflow can accept.\n        ", "meta": {"scope": ["Workflow", "input_types"], "position": {"start": {"line": 810, "column": 8}, "end": {"line": 816, "column": 11}}, "target": "input_types", "qualname": "Workflow::input_types"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow.py", "kind": "function_docstring", "text": "Get the output types of the workflow.\n\n        The output types are the list of all workflow output types from executors\n        that have workflow output types.\n\n        Returns:\n            A list of output types that the workflow can produce.\n        ", "meta": {"scope": ["Workflow", "output_types"], "position": {"start": {"line": 822, "column": 8}, "end": {"line": 829, "column": 11}}, "target": "output_types", "qualname": "Workflow::output_types"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow.py", "kind": "function_docstring", "text": "Create a WorkflowAgent that wraps this workflow.\n\n        The returned agent converts standard agent inputs (strings, ChatMessage, or lists of these)\n        into a list[ChatMessage] that is passed to the workflow's start executor. This conversion\n        happens in WorkflowAgent._normalize_messages() which transforms:\n        - str -> [ChatMessage(role=USER, text=str)]\n        - ChatMessage -> [ChatMessage]\n        - list[str | ChatMessage] -> list[ChatMessage] (with string elements converted)\n\n        The workflow's start executor must accept list[ChatMessage] as an input type, otherwise\n        initialization will fail with a ValueError.\n\n        Args:\n            name: Optional name for the agent. If None, a default name will be generated.\n\n        Returns:\n            A WorkflowAgent instance that wraps this workflow.\n\n        Raises:\n            ValueError: If the workflow's start executor cannot handle list[ChatMessage] input.\n        ", "meta": {"scope": ["Workflow", "as_agent"], "position": {"start": {"line": 839, "column": 8}, "end": {"line": 859, "column": 11}}, "target": "as_agent", "qualname": "Workflow::as_agent"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow.py", "kind": "comment", "text": "Import here to avoid circular imports", "meta": {"scope": ["Workflow", "as_agent"], "position": {"start": {"line": 860, "column": 8}, "end": {"line": 860, "column": 47}}, "comment_type": "block", "line_count": 1, "original_block": "        # Import here to avoid circular imports\n", "qualname": "Workflow::as_agent"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow_builder.py", "kind": "comment", "text": "Copyright (c) Microsoft. All rights reserved.", "meta": {"scope": [], "position": {"start": {"line": 1, "column": 0}, "end": {"line": 1, "column": 47}}, "comment_type": "block", "line_count": 1, "original_block": "# Copyright (c) Microsoft. All rights reserved.\n"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow_builder.py", "kind": "class_docstring", "text": "A builder class for constructing workflows.\n\n    This class provides methods to add edges and set the starting executor for the workflow.\n    ", "meta": {"scope": ["WorkflowBuilder"], "position": {"start": {"line": 39, "column": 4}, "end": {"line": 42, "column": 7}}, "target": "WorkflowBuilder", "qualname": "WorkflowBuilder"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow_builder.py", "kind": "function_docstring", "text": "Initialize the WorkflowBuilder with an empty list of edges and no starting executor.\n\n        Args:\n            max_iterations: Maximum number of iterations for workflow convergence.\n            name: Optional human-readable name for the workflow.\n            description: Optional description of what the workflow does.\n        ", "meta": {"scope": ["WorkflowBuilder", "__init__"], "position": {"start": {"line": 50, "column": 8}, "end": {"line": 56, "column": 11}}, "target": "__init__", "qualname": "WorkflowBuilder::__init__"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow_builder.py", "kind": "comment", "text": "Maps underlying AgentProtocol object id -> wrapped Executor so we reuse the same wrapper\nacross set_start_executor / add_edge calls. Without this, unnamed agents (which receive\nrandom UUID based executor ids) end up wrapped multiple times, giving different ids for\nthe start node vs edge nodes and triggering a GraphConnectivityError during validation.", "meta": {"scope": ["WorkflowBuilder", "__init__"], "position": {"start": {"line": 65, "column": 8}, "end": {"line": 68, "column": 97}}, "comment_type": "block", "line_count": 4, "original_block": "        # Maps underlying AgentProtocol object id -> wrapped Executor so we reuse the same wrapper\n        # across set_start_executor / add_edge calls. Without this, unnamed agents (which receive\n        # random UUID based executor ids) end up wrapped multiple times, giving different ids for\n        # the start node vs edge nodes and triggering a GraphConnectivityError during validation.\n", "qualname": "WorkflowBuilder::__init__"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow_builder.py", "kind": "function_docstring", "text": "Add an executor to the map and return its ID.", "meta": {"scope": ["WorkflowBuilder", "_add_executor"], "position": {"start": {"line": 74, "column": 8}, "end": {"line": 74, "column": 59}}, "target": "_add_executor", "qualname": "WorkflowBuilder::_add_executor"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow_builder.py", "kind": "comment", "text": "Agents auto-wrapped by builder now always stream incremental updates.", "meta": {"scope": ["WorkflowBuilder", "_add_executor"], "position": {"start": {"line": 71, "column": 4}, "end": {"line": 71, "column": 75}}, "comment_type": "block", "line_count": 1, "original_block": "    # Agents auto-wrapped by builder now always stream incremental updates.\n", "qualname": "WorkflowBuilder::_add_executor"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow_builder.py", "kind": "function_docstring", "text": "If the provided object implements AgentProtocol, wrap it in an AgentExecutor.\n\n        This allows fluent builder APIs to directly accept agents instead of\n        requiring callers to manually instantiate AgentExecutor.\n\n        Args:\n            candidate: The executor or agent to wrap.\n            agent_thread: The thread to use for running the agent. If None, a new thread will be created.\n            output_response: Whether to yield an AgentRunResponse as a workflow output when the agent completes.\n            executor_id: A unique identifier for the executor. If None, the agent's name will be used if available.\n        ", "meta": {"scope": ["WorkflowBuilder", "_maybe_wrap_agent"], "position": {"start": {"line": 89, "column": 8}, "end": {"line": 99, "column": 11}}, "target": "_maybe_wrap_agent", "qualname": "WorkflowBuilder::_maybe_wrap_agent"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow_builder.py", "kind": "comment", "text": "Reuse existing wrapper for the same agent instance if present", "meta": {"scope": ["WorkflowBuilder", "_maybe_wrap_agent"], "position": {"start": {"line": 108, "column": 12}, "end": {"line": 108, "column": 75}}, "comment_type": "block", "line_count": 1, "original_block": "            # Reuse existing wrapper for the same agent instance if present\n", "qualname": "WorkflowBuilder::_maybe_wrap_agent"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow_builder.py", "kind": "comment", "text": "Use agent name if available and unique among current executors", "meta": {"scope": ["WorkflowBuilder", "_maybe_wrap_agent"], "position": {"start": {"line": 113, "column": 12}, "end": {"line": 113, "column": 76}}, "comment_type": "block", "line_count": 1, "original_block": "            # Use agent name if available and unique among current executors\n", "qualname": "WorkflowBuilder::_maybe_wrap_agent"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow_builder.py", "kind": "function_docstring", "text": "Add an agent to the workflow by wrapping it in an AgentExecutor.\n\n        This method creates an AgentExecutor that wraps the agent with the given parameters\n        and ensures that subsequent uses of the same agent instance in other builder methods\n        (like add_edge, set_start_executor, etc.) will reuse the same wrapped executor.\n\n        Note: Agents adapt their behavior based on how the workflow is executed:\n        - run_stream(): Agents emit incremental AgentRunUpdateEvent events as tokens are produced\n        - run(): Agents emit a single AgentRunEvent containing the complete response\n\n        Args:\n            agent: The agent to add to the workflow.\n            agent_thread: The thread to use for running the agent. If None, a new thread will be created.\n            output_response: Whether to yield an AgentRunResponse as a workflow output when the agent completes.\n            id: A unique identifier for the executor. If None, the agent's name will be used if available.\n\n        Returns:\n            The WorkflowBuilder instance (for method chaining).\n\n        Raises:\n            ValueError: If the provided id or agent name conflicts with an existing executor.\n        ", "meta": {"scope": ["WorkflowBuilder", "add_agent"], "position": {"start": {"line": 142, "column": 8}, "end": {"line": 163, "column": 11}}, "target": "add_agent", "qualname": "WorkflowBuilder::add_agent"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow_builder.py", "kind": "function_docstring", "text": "Add a directed edge between two executors.\n\n        The output types of the source and the input types of the target must be compatible.\n\n        Args:\n            source: The source executor of the edge.\n            target: The target executor of the edge.\n            condition: An optional condition function that determines whether the edge\n                       should be traversed based on the message type.\n        ", "meta": {"scope": ["WorkflowBuilder", "add_edge"], "position": {"start": {"line": 176, "column": 8}, "end": {"line": 185, "column": 11}}, "target": "add_edge", "qualname": "WorkflowBuilder::add_edge"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow_builder.py", "kind": "comment", "text": "TODO(@taochen): Support executor factories for lazy initialization", "meta": {"scope": ["WorkflowBuilder", "add_edge"], "position": {"start": {"line": 186, "column": 8}, "end": {"line": 186, "column": 76}}, "comment_type": "block", "line_count": 1, "original_block": "        # TODO(@taochen): Support executor factories for lazy initialization\n", "qualname": "WorkflowBuilder::add_edge"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow_builder.py", "kind": "function_docstring", "text": "Add multiple edges to the workflow where messages from the source will be sent to all target.\n\n        The output types of the source and the input types of the targets must be compatible.\n\n        Args:\n            source: The source executor of the edges.\n            targets: A list of target executors for the edges.\n        ", "meta": {"scope": ["WorkflowBuilder", "add_fan_out_edges"], "position": {"start": {"line": 199, "column": 8}, "end": {"line": 206, "column": 11}}, "target": "add_fan_out_edges", "qualname": "WorkflowBuilder::add_fan_out_edges"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow_builder.py", "kind": "function_docstring", "text": "Add an edge group that represents a switch-case statement.\n\n        The output types of the source and the input types of the targets must be compatible.\n        Messages from the source executor will be sent to one of the target executors based on\n        the provided conditions.\n\n        Think of this as a switch statement where each target executor corresponds to a case.\n        Each condition function will be evaluated in order, and the first one that returns True\n        will determine which target executor receives the message.\n\n        The last case (the default case) will receive messages that fall through all conditions\n        (i.e., no condition matched).\n\n        Args:\n            source: The source executor of the edges.\n            cases: A list of case objects that determine the target executor for each message.\n        ", "meta": {"scope": ["WorkflowBuilder", "add_switch_case_edge_group"], "position": {"start": {"line": 220, "column": 8}, "end": {"line": 236, "column": 11}}, "target": "add_switch_case_edge_group", "qualname": "WorkflowBuilder::add_switch_case_edge_group"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow_builder.py", "kind": "comment", "text": "Convert case data types to internal types that only uses target_id.", "meta": {"scope": ["WorkflowBuilder", "add_switch_case_edge_group"], "position": {"start": {"line": 239, "column": 8}, "end": {"line": 239, "column": 77}}, "comment_type": "block", "line_count": 1, "original_block": "        # Convert case data types to internal types that only uses target_id.\n", "qualname": "WorkflowBuilder::add_switch_case_edge_group"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow_builder.py", "kind": "comment", "text": "Allow case targets to be agents", "meta": {"scope": ["WorkflowBuilder", "add_switch_case_edge_group"], "position": {"start": {"line": 242, "column": 12}, "end": {"line": 242, "column": 45}}, "comment_type": "block", "line_count": 1, "original_block": "            # Allow case targets to be agents\n", "qualname": "WorkflowBuilder::add_switch_case_edge_group"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow_builder.py", "kind": "function_docstring", "text": "Add an edge group that represents a multi-selection execution model.\n\n        The output types of the source and the input types of the targets must be compatible.\n        Messages from the source executor will be sent to multiple target executors based on\n        the provided selection function.\n\n        The selection function should take a message and the name of the target executors,\n        and return a list of indices indicating which target executors should receive the message.\n\n        Args:\n            source: The source executor of the edges.\n            targets: A list of target executors for the edges.\n            selection_func: A function that selects target executors for messages.\n        ", "meta": {"scope": ["WorkflowBuilder", "add_multi_selection_edge_group"], "position": {"start": {"line": 259, "column": 8}, "end": {"line": 272, "column": 11}}, "target": "add_multi_selection_edge_group", "qualname": "WorkflowBuilder::add_multi_selection_edge_group"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow_builder.py", "kind": "function_docstring", "text": "Add multiple edges from sources to a single target executor.\n\n        The edges will be grouped together for synchronized processing, meaning\n        the target executor will only be executed once all source executors have completed.\n\n        The target executor will receive a list of messages aggregated from all source executors.\n        Thus the input types of the target executor must be compatible with a list of the output\n        types of the source executors. For example:\n\n            class Target(Executor):\n                @handler\n                def handle_messages(self, messages: list[Message]) -> None:\n                    # Process the aggregated messages from all sources\n\n            class Source(Executor):\n                @handler(output_type=[Message])\n                def handle_message(self, message: Message) -> None:\n                    # Send a message to the target executor\n                    self.send_message(message)\n\n            workflow = (\n                WorkflowBuilder()\n                .add_fan_in_edges(\n                    [Source(id=\"source1\"), Source(id=\"source2\")],\n                    Target(id=\"target\")\n                )\n                .build()\n            )\n\n        Args:\n            sources: A list of source executors for the edges.\n            target: The target executor for the edges.\n        ", "meta": {"scope": ["WorkflowBuilder", "add_fan_in_edges"], "position": {"start": {"line": 286, "column": 8}, "end": {"line": 318, "column": 11}}, "target": "add_fan_in_edges", "qualname": "WorkflowBuilder::add_fan_in_edges"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow_builder.py", "kind": "function_docstring", "text": "Add a chain of executors to the workflow.\n\n        The output of each executor in the chain will be sent to the next executor in the chain.\n        The input types of each executor must be compatible with the output types of the previous executor.\n\n        Circles in the chain are not allowed, meaning the chain cannot have two executors with the same ID.\n\n        Args:\n            executors: A list of executors to be added to the chain.\n        ", "meta": {"scope": ["WorkflowBuilder", "add_chain"], "position": {"start": {"line": 328, "column": 8}, "end": {"line": 337, "column": 11}}, "target": "add_chain", "qualname": "WorkflowBuilder::add_chain"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow_builder.py", "kind": "comment", "text": "Wrap each candidate first to ensure stable IDs before adding edges", "meta": {"scope": ["WorkflowBuilder", "add_chain"], "position": {"start": {"line": 338, "column": 8}, "end": {"line": 338, "column": 76}}, "comment_type": "block", "line_count": 1, "original_block": "        # Wrap each candidate first to ensure stable IDs before adding edges\n", "qualname": "WorkflowBuilder::add_chain"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow_builder.py", "kind": "function_docstring", "text": "Set the starting executor for the workflow.\n\n        Args:\n            executor: The starting executor, which can be an Executor instance or its ID.\n        ", "meta": {"scope": ["WorkflowBuilder", "set_start_executor"], "position": {"start": {"line": 345, "column": 8}, "end": {"line": 349, "column": 11}}, "target": "set_start_executor", "qualname": "WorkflowBuilder::set_start_executor"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow_builder.py", "kind": "comment", "text": "Ensure the start executor is present in the executor map so validation succeeds\neven if no edges are added yet, or before edges wrap the same agent again.", "meta": {"scope": ["WorkflowBuilder", "set_start_executor"], "position": {"start": {"line": 355, "column": 12}, "end": {"line": 356, "column": 88}}, "comment_type": "block", "line_count": 2, "original_block": "            # Ensure the start executor is present in the executor map so validation succeeds\n            # even if no edges are added yet, or before edges wrap the same agent again.\n", "qualname": "WorkflowBuilder::set_start_executor"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow_builder.py", "kind": "function_docstring", "text": "Set the maximum number of iterations for the workflow.\n\n        Args:\n            max_iterations: The maximum number of iterations the workflow will run for convergence.\n        ", "meta": {"scope": ["WorkflowBuilder", "set_max_iterations"], "position": {"start": {"line": 363, "column": 8}, "end": {"line": 367, "column": 11}}, "target": "set_max_iterations", "qualname": "WorkflowBuilder::set_max_iterations"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow_builder.py", "kind": "function_docstring", "text": "Enable checkpointing with the specified storage.\n\n        Args:\n            checkpoint_storage: The checkpoint storage to use.\n        ", "meta": {"scope": ["WorkflowBuilder", "with_checkpointing"], "position": {"start": {"line": 374, "column": 8}, "end": {"line": 378, "column": 11}}, "target": "with_checkpointing", "qualname": "WorkflowBuilder::with_checkpointing"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow_builder.py", "kind": "comment", "text": "Removed explicit set_agent_streaming() API; agents always stream updates.", "meta": {"scope": ["WorkflowBuilder", "with_checkpointing"], "position": {"start": {"line": 371, "column": 4}, "end": {"line": 371, "column": 79}}, "comment_type": "block", "line_count": 1, "original_block": "    # Removed explicit set_agent_streaming() API; agents always stream updates.\n", "qualname": "WorkflowBuilder::with_checkpointing"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow_builder.py", "kind": "function_docstring", "text": "Build and return the constructed workflow.\n\n        This method performs validation before building the workflow.\n\n        Returns:\n            A Workflow instance with the defined edges and starting executor.\n\n        Raises:\n            ValueError: If starting executor is not set.\n            WorkflowValidationError: If workflow validation fails (includes EdgeDuplicationError,\n                TypeCompatibilityError, and GraphConnectivityError subclasses).\n        ", "meta": {"scope": ["WorkflowBuilder", "build"], "position": {"start": {"line": 383, "column": 8}, "end": {"line": 394, "column": 11}}, "target": "build", "qualname": "WorkflowBuilder::build"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow_builder.py", "kind": "comment", "text": "Create workflow build span that includes validation and workflow creation", "meta": {"scope": ["WorkflowBuilder", "build"], "position": {"start": {"line": 395, "column": 8}, "end": {"line": 395, "column": 83}}, "comment_type": "block", "line_count": 1, "original_block": "        # Create workflow build span that includes validation and workflow creation\n", "qualname": "WorkflowBuilder::build"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow_builder.py", "kind": "comment", "text": "Add workflow build started event", "meta": {"scope": ["WorkflowBuilder", "build"], "position": {"start": {"line": 398, "column": 16}, "end": {"line": 398, "column": 50}}, "comment_type": "block", "line_count": 1, "original_block": "                # Add workflow build started event\n", "qualname": "WorkflowBuilder::build"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow_builder.py", "kind": "comment", "text": "Perform validation before creating the workflow", "meta": {"scope": ["WorkflowBuilder", "build"], "position": {"start": {"line": 406, "column": 16}, "end": {"line": 406, "column": 65}}, "comment_type": "block", "line_count": 1, "original_block": "                # Perform validation before creating the workflow\n", "qualname": "WorkflowBuilder::build"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow_builder.py", "kind": "comment", "text": "Add validation completed event", "meta": {"scope": ["WorkflowBuilder", "build"], "position": {"start": {"line": 414, "column": 16}, "end": {"line": 414, "column": 48}}, "comment_type": "block", "line_count": 1, "original_block": "                # Add validation completed event\n", "qualname": "WorkflowBuilder::build"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow_builder.py", "kind": "comment", "text": "Create workflow instance after validation", "meta": {"scope": ["WorkflowBuilder", "build"], "position": {"start": {"line": 419, "column": 16}, "end": {"line": 419, "column": 59}}, "comment_type": "block", "line_count": 1, "original_block": "                # Create workflow instance after validation\n", "qualname": "WorkflowBuilder::build"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow_builder.py", "kind": "comment", "text": "Add workflow build completed event", "meta": {"scope": ["WorkflowBuilder", "build"], "position": {"start": {"line": 439, "column": 16}, "end": {"line": 439, "column": 52}}, "comment_type": "block", "line_count": 1, "original_block": "                # Add workflow build completed event\n", "qualname": "WorkflowBuilder::build"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow_context.py", "kind": "comment", "text": "Copyright (c) Microsoft. All rights reserved.", "meta": {"scope": [], "position": {"start": {"line": 1, "column": 0}, "end": {"line": 1, "column": 47}}, "comment_type": "block", "line_count": 1, "original_block": "# Copyright (c) Microsoft. All rights reserved.\n"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow_executor.py", "kind": "class_docstring", "text": "An executor that wraps a workflow to enable hierarchical workflow composition.\n\n    ## Overview\n    WorkflowExecutor makes a workflow behave as a single executor within a parent workflow,\n    enabling nested workflow architectures. It handles the complete lifecycle of sub-workflow\n    execution including event processing, output forwarding, and request/response coordination\n    between parent and child workflows.\n\n    ## Execution Model\n    When invoked, WorkflowExecutor:\n    1. Starts the wrapped workflow with the input message\n    2. Runs the sub-workflow to completion or until it needs external input\n    3. Processes the sub-workflow's complete event stream after execution\n    4. Forwards outputs to the parent workflow's event stream\n    5. Handles external requests by routing them to the parent workflow\n    6. Accumulates responses and resumes sub-workflow execution\n\n    ## Event Stream Processing\n    WorkflowExecutor processes events after sub-workflow completion:\n\n    ### Output Forwarding\n    All outputs from the sub-workflow are automatically forwarded to the parent:\n\n    .. code-block:: python\n\n        # Sub-workflow yields outputs\n        await ctx.yield_output(\"sub-workflow result\")\n\n        # WorkflowExecutor forwards to parent via ctx.send_message()\n        # Parent receives the output as a regular message\n\n    ### Request/Response Coordination\n    When sub-workflows need external information:\n\n    .. code-block:: python\n\n        # Sub-workflow makes request\n        request = MyDataRequest(query=\"user info\")\n        # RequestInfoExecutor emits RequestInfoEvent\n\n        # WorkflowExecutor sets source_executor_id and forwards to parent\n        request.source_executor_id = \"child_workflow_executor_id\"\n        # Parent workflow can handle via @handler for RequestInfoMessage subclasses,\n        # or directly forward to external source via a RequestInfoExecutor in the parent\n        # workflow.\n\n    ### State Management\n    WorkflowExecutor maintains execution state across request/response cycles:\n    - Tracks pending requests by request_id\n    - Accumulates responses until all expected responses are received\n    - Resumes sub-workflow execution with complete response batch\n    - Handles concurrent executions and multiple pending requests\n\n    ## Type System Integration\n    WorkflowExecutor inherits its type signature from the wrapped workflow:\n\n    ### Input Types\n    Matches the wrapped workflow's start executor input types:\n\n    .. code-block:: python\n\n        # If sub-workflow accepts str, WorkflowExecutor accepts str\n        workflow_executor = WorkflowExecutor(my_workflow, id=\"wrapper\")\n        assert workflow_executor.input_types == my_workflow.input_types\n\n    ### Output Types\n    Combines sub-workflow outputs with request coordination types:\n\n    .. code-block:: python\n\n        # Includes all sub-workflow output types\n        # Plus RequestInfoMessage if sub-workflow can make requests\n    output_types = workflow.output_types + [RequestInfoMessage]  # if applicable\n    ```\n\n    ## Error Handling\n    WorkflowExecutor propagates sub-workflow failures:\n    - Captures WorkflowFailedEvent from sub-workflow\n    - Converts to WorkflowErrorEvent in parent context\n    - Provides detailed error information including sub-workflow ID\n\n    ## Concurrent Execution Support\n    WorkflowExecutor fully supports multiple concurrent sub-workflow executions:\n\n    ### Per-Execution State Isolation\n    Each sub-workflow invocation creates an isolated ExecutionContext:\n\n    .. code-block:: python\n\n        # Multiple concurrent invocations are supported\n        workflow_executor = WorkflowExecutor(my_workflow, id=\"concurrent_executor\")\n\n        # Each invocation gets its own execution context\n        # Execution 1: processes input_1 independently\n        # Execution 2: processes input_2 independently\n        # No state interference between executions\n\n    ### Request/Response Coordination\n    Responses are correctly routed to the originating execution:\n    - Each execution tracks its own pending requests and expected responses\n    - Request-to-execution mapping ensures responses reach the correct sub-workflow\n    - Response accumulation is isolated per execution\n    - Automatic cleanup when execution completes\n\n    ### Memory Management\n    - Unlimited concurrent executions supported\n    - Each execution has unique UUID-based identification\n    - Cleanup of completed execution contexts\n    - Thread-safe state management for concurrent access\n\n    ### Important Considerations\n    **Shared Workflow Instance**: All concurrent executions use the same underlying workflow instance.\n    For proper isolation, ensure that:\n    - The wrapped workflow and its executors are stateless\n    - Executors use WorkflowContext state management instead of instance variables\n    - Any shared state is managed through WorkflowContext.get_shared_state/set_shared_state\n\n    .. code-block:: python\n\n        # Good: Stateless executor using context state\n        class StatelessExecutor(Executor):\n            @handler\n            async def process(self, data: str, ctx: WorkflowContext[str]) -> None:\n                # Use context state instead of instance variables\n                state = await ctx.get_executor_state() or {}\n                state[\"processed\"] = data\n                await ctx.set_executor_state(state)\n\n\n        # Avoid: Stateful executor with instance variables\n        class StatefulExecutor(Executor):\n            def __init__(self):\n                super().__init__(id=\"stateful\")\n                self.data = []  # This will be shared across concurrent executions!\n\n    ## Integration with Parent Workflows\n    Parent workflows can intercept sub-workflow requests:\n    ```python\n    class ParentExecutor(Executor):\n        @handler\n        async def handle_request(\n            self,\n            request: MyRequestType,  # Subclass of RequestInfoMessage\n            ctx: WorkflowContext[RequestResponse[RequestInfoMessage, Any] | RequestInfoMessage],\n        ) -> None:\n            # Handle request locally or forward to external source\n            if self.can_handle_locally(request):\n                # Send response back to sub-workflow\n                response = RequestResponse(data=\"local result\", original_request=request, request_id=request.request_id)\n                await ctx.send_message(response, target_id=request.source_executor_id)\n            else:\n                # Forward to external handler\n                await ctx.send_message(request)\n    ```\n\n    ## Implementation Notes\n    - Sub-workflows run to completion before processing their results\n    - Event processing is atomic - all outputs are forwarded before requests\n    - Response accumulation ensures sub-workflows receive complete response batches\n    - Execution state is maintained for proper resumption after external requests\n    - Concurrent executions are fully isolated and do not interfere with each other\n    ", "meta": {"scope": ["WorkflowExecutor"], "position": {"start": {"line": 46, "column": 4}, "end": {"line": 207, "column": 7}}, "target": "WorkflowExecutor", "qualname": "WorkflowExecutor"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow_executor.py", "kind": "function_docstring", "text": "Initialize the WorkflowExecutor.\n\n        Args:\n            workflow: The workflow to execute as a sub-workflow.\n            id: Unique identifier for this executor.\n\n        Keyword Args:\n            **kwargs: Additional keyword arguments passed to the parent constructor.\n        ", "meta": {"scope": ["WorkflowExecutor", "__init__"], "position": {"start": {"line": 210, "column": 8}, "end": {"line": 218, "column": 11}}, "target": "__init__", "qualname": "WorkflowExecutor::__init__"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow_executor.py", "kind": "comment", "text": "execution_id -> ExecutionContext", "meta": {"scope": ["WorkflowExecutor", "__init__"], "position": {"start": {"line": 223, "column": 68}, "end": {"line": 223, "column": 102}}, "comment_type": "inline", "original_line": "        self._execution_contexts: dict[str, ExecutionContext] = {}  # execution_id -> ExecutionContext\n", "qualname": "WorkflowExecutor::__init__"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow_executor.py", "kind": "comment", "text": "Track execution contexts for concurrent sub-workflow executions", "meta": {"scope": ["WorkflowExecutor", "__init__"], "position": {"start": {"line": 222, "column": 8}, "end": {"line": 222, "column": 73}}, "comment_type": "block", "line_count": 1, "original_block": "        # Track execution contexts for concurrent sub-workflow executions\n", "qualname": "WorkflowExecutor::__init__"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow_executor.py", "kind": "comment", "text": "request_id -> execution_id", "meta": {"scope": ["WorkflowExecutor", "__init__"], "position": {"start": {"line": 225, "column": 57}, "end": {"line": 225, "column": 85}}, "comment_type": "inline", "original_line": "        self._request_to_execution: dict[str, str] = {}  # request_id -> execution_id\n", "qualname": "WorkflowExecutor::__init__"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow_executor.py", "kind": "comment", "text": "Map request_id to execution_id for response routing", "meta": {"scope": ["WorkflowExecutor", "__init__"], "position": {"start": {"line": 224, "column": 8}, "end": {"line": 224, "column": 61}}, "comment_type": "block", "line_count": 1, "original_block": "        # Map request_id to execution_id for response routing\n", "qualname": "WorkflowExecutor::__init__"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow_executor.py", "kind": "comment", "text": "Count of active sub-workflow executions", "meta": {"scope": ["WorkflowExecutor", "__init__"], "position": {"start": {"line": 226, "column": 42}, "end": {"line": 226, "column": 83}}, "comment_type": "inline", "original_line": "        self._active_executions: int = 0  # Count of active sub-workflow executions\n", "qualname": "WorkflowExecutor::__init__"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow_executor.py", "kind": "function_docstring", "text": "Get the input types based on the underlying workflow's input types plus WorkflowExecutor-specific types.\n\n        Returns:\n            A list of input types that the WorkflowExecutor can accept.\n        ", "meta": {"scope": ["WorkflowExecutor", "input_types"], "position": {"start": {"line": 231, "column": 8}, "end": {"line": 235, "column": 11}}, "target": "input_types", "qualname": "WorkflowExecutor::input_types"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow_executor.py", "kind": "comment", "text": "WorkflowExecutor can also handle RequestResponse for sub-workflow responses", "meta": {"scope": ["WorkflowExecutor", "input_types"], "position": {"start": {"line": 238, "column": 8}, "end": {"line": 238, "column": 85}}, "comment_type": "block", "line_count": 1, "original_block": "        # WorkflowExecutor can also handle RequestResponse for sub-workflow responses\n", "qualname": "WorkflowExecutor::input_types"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow_executor.py", "kind": "function_docstring", "text": "Get the output types based on the underlying workflow's output types.\n\n        Returns:\n            A list of output types that the underlying workflow can produce.\n            Includes specific RequestInfoMessage subtypes if the sub-workflow contains RequestInfoExecutor.\n        ", "meta": {"scope": ["WorkflowExecutor", "output_types"], "position": {"start": {"line": 246, "column": 8}, "end": {"line": 251, "column": 11}}, "target": "output_types", "qualname": "WorkflowExecutor::output_types"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow_executor.py", "kind": "comment", "text": "Check if the sub-workflow contains a RequestInfoExecutor\nIf so, collect the specific RequestInfoMessage subtypes from all executors", "meta": {"scope": ["WorkflowExecutor", "output_types"], "position": {"start": {"line": 254, "column": 8}, "end": {"line": 255, "column": 84}}, "comment_type": "block", "line_count": 2, "original_block": "        # Check if the sub-workflow contains a RequestInfoExecutor\n        # If so, collect the specific RequestInfoMessage subtypes from all executors\n", "qualname": "WorkflowExecutor::output_types"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow_executor.py", "kind": "comment", "text": "Collect all RequestInfoMessage subtypes from executor output types", "meta": {"scope": ["WorkflowExecutor", "output_types"], "position": {"start": {"line": 261, "column": 12}, "end": {"line": 261, "column": 80}}, "comment_type": "block", "line_count": 1, "original_block": "            # Collect all RequestInfoMessage subtypes from executor output types\n", "qualname": "WorkflowExecutor::output_types"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow_executor.py", "kind": "comment", "text": "Check if this is a RequestInfoMessage subclass", "meta": {"scope": ["WorkflowExecutor", "output_types"], "position": {"start": {"line": 264, "column": 20}, "end": {"line": 264, "column": 68}}, "comment_type": "block", "line_count": 1, "original_block": "                    # Check if this is a RequestInfoMessage subclass\n", "qualname": "WorkflowExecutor::output_types"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow_executor.py", "kind": "function_docstring", "text": "Override can_handle to only accept messages that the wrapped workflow can handle.\n\n        This prevents the WorkflowExecutor from accepting messages that should go to other\n        executors (like RequestInfoExecutor).\n        ", "meta": {"scope": ["WorkflowExecutor", "can_handle"], "position": {"start": {"line": 280, "column": 8}, "end": {"line": 284, "column": 11}}, "target": "can_handle", "qualname": "WorkflowExecutor::can_handle"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow_executor.py", "kind": "comment", "text": "Always handle RequestResponse (for the handle_response handler)", "meta": {"scope": ["WorkflowExecutor", "can_handle"], "position": {"start": {"line": 285, "column": 8}, "end": {"line": 285, "column": 73}}, "comment_type": "block", "line_count": 1, "original_block": "        # Always handle RequestResponse (for the handle_response handler)\n", "qualname": "WorkflowExecutor::can_handle"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow_executor.py", "kind": "comment", "text": "For other messages, only handle if the wrapped workflow can accept them as input", "meta": {"scope": ["WorkflowExecutor", "can_handle"], "position": {"start": {"line": 289, "column": 8}, "end": {"line": 289, "column": 90}}, "comment_type": "block", "line_count": 1, "original_block": "        # For other messages, only handle if the wrapped workflow can accept them as input\n", "qualname": "WorkflowExecutor::can_handle"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow_executor.py", "kind": "function_docstring", "text": "Execute the sub-workflow with raw input data.\n\n        This handler starts a new sub-workflow execution. When the sub-workflow\n        needs external information, it pauses and sends a request to the parent.\n\n        Args:\n            input_data: The input data to send to the sub-workflow.\n            ctx: The workflow context from the parent.\n        ", "meta": {"scope": ["WorkflowExecutor", "process_workflow"], "position": {"start": {"line": 294, "column": 8}, "end": {"line": 302, "column": 11}}, "target": "process_workflow", "qualname": "WorkflowExecutor::process_workflow"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow_executor.py", "kind": "comment", "text": "Skip RequestResponse - it has a specific handler", "meta": {"scope": ["WorkflowExecutor", "process_workflow"], "position": {"start": {"line": 303, "column": 8}, "end": {"line": 303, "column": 58}}, "comment_type": "block", "line_count": 1, "original_block": "        # Skip RequestResponse - it has a specific handler\n", "qualname": "WorkflowExecutor::process_workflow"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow_executor.py", "kind": "comment", "text": "Create execution context for this sub-workflow run", "meta": {"scope": ["WorkflowExecutor", "process_workflow"], "position": {"start": {"line": 310, "column": 8}, "end": {"line": 310, "column": 60}}, "comment_type": "block", "line_count": 1, "original_block": "        # Create execution context for this sub-workflow run\n", "qualname": "WorkflowExecutor::process_workflow"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow_executor.py", "kind": "comment", "text": "Track this execution", "meta": {"scope": ["WorkflowExecutor", "process_workflow"], "position": {"start": {"line": 320, "column": 8}, "end": {"line": 320, "column": 30}}, "comment_type": "block", "line_count": 1, "original_block": "        # Track this execution\n", "qualname": "WorkflowExecutor::process_workflow"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow_executor.py", "kind": "comment", "text": "Run the sub-workflow and collect all events", "meta": {"scope": ["WorkflowExecutor", "process_workflow"], "position": {"start": {"line": 326, "column": 12}, "end": {"line": 326, "column": 57}}, "comment_type": "block", "line_count": 1, "original_block": "            # Run the sub-workflow and collect all events\n", "qualname": "WorkflowExecutor::process_workflow"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow_executor.py", "kind": "comment", "text": "Process the workflow result using shared logic", "meta": {"scope": ["WorkflowExecutor", "process_workflow"], "position": {"start": {"line": 334, "column": 12}, "end": {"line": 334, "column": 60}}, "comment_type": "block", "line_count": 1, "original_block": "            # Process the workflow result using shared logic\n", "qualname": "WorkflowExecutor::process_workflow"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow_executor.py", "kind": "comment", "text": "Clean up execution context if it's completed (no pending requests)", "meta": {"scope": ["WorkflowExecutor", "process_workflow"], "position": {"start": {"line": 337, "column": 12}, "end": {"line": 337, "column": 80}}, "comment_type": "block", "line_count": 1, "original_block": "            # Clean up execution context if it's completed (no pending requests)\n", "qualname": "WorkflowExecutor::process_workflow"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow_executor.py", "kind": "function_docstring", "text": "Process the result from a workflow execution.\n\n        This method handles the common logic for processing outputs, request info events,\n        and final states that is shared between process_workflow and handle_response.\n\n        Args:\n            result: The workflow execution result.\n            execution_context: The execution context for this sub-workflow run.\n            ctx: The workflow context.\n        ", "meta": {"scope": ["WorkflowExecutor", "_process_workflow_result"], "position": {"start": {"line": 347, "column": 8}, "end": {"line": 356, "column": 11}}, "target": "_process_workflow_result", "qualname": "WorkflowExecutor::_process_workflow_result"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow_executor.py", "kind": "comment", "text": "Collect all events from the workflow", "meta": {"scope": ["WorkflowExecutor", "_process_workflow_result"], "position": {"start": {"line": 357, "column": 8}, "end": {"line": 357, "column": 46}}, "comment_type": "block", "line_count": 1, "original_block": "        # Collect all events from the workflow\n", "qualname": "WorkflowExecutor::_process_workflow_result"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow_executor.py", "kind": "comment", "text": "Process outputs", "meta": {"scope": ["WorkflowExecutor", "_process_workflow_result"], "position": {"start": {"line": 367, "column": 8}, "end": {"line": 367, "column": 25}}, "comment_type": "block", "line_count": 1, "original_block": "        # Process outputs\n", "qualname": "WorkflowExecutor::_process_workflow_result"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow_executor.py", "kind": "comment", "text": "Process request info events", "meta": {"scope": ["WorkflowExecutor", "_process_workflow_result"], "position": {"start": {"line": 371, "column": 8}, "end": {"line": 371, "column": 37}}, "comment_type": "block", "line_count": 1, "original_block": "        # Process request info events\n", "qualname": "WorkflowExecutor::_process_workflow_result"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow_executor.py", "kind": "comment", "text": "Track the pending request in execution context", "meta": {"scope": ["WorkflowExecutor", "_process_workflow_result"], "position": {"start": {"line": 373, "column": 12}, "end": {"line": 373, "column": 60}}, "comment_type": "block", "line_count": 1, "original_block": "            # Track the pending request in execution context\n", "qualname": "WorkflowExecutor::_process_workflow_result"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow_executor.py", "kind": "comment", "text": "Map request to execution for response routing", "meta": {"scope": ["WorkflowExecutor", "_process_workflow_result"], "position": {"start": {"line": 375, "column": 12}, "end": {"line": 375, "column": 59}}, "comment_type": "block", "line_count": 1, "original_block": "            # Map request to execution for response routing\n", "qualname": "WorkflowExecutor::_process_workflow_result"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow_executor.py", "kind": "comment", "text": "Set source_executor_id for response routing and send to parent", "meta": {"scope": ["WorkflowExecutor", "_process_workflow_result"], "position": {"start": {"line": 377, "column": 12}, "end": {"line": 377, "column": 76}}, "comment_type": "block", "line_count": 1, "original_block": "            # Set source_executor_id for response routing and send to parent\n", "qualname": "WorkflowExecutor::_process_workflow_result"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow_executor.py", "kind": "comment", "text": "Set the source_executor_id to this WorkflowExecutor's ID for response routing", "meta": {"scope": ["WorkflowExecutor", "_process_workflow_result"], "position": {"start": {"line": 380, "column": 12}, "end": {"line": 380, "column": 91}}, "comment_type": "block", "line_count": 1, "original_block": "            # Set the source_executor_id to this WorkflowExecutor's ID for response routing\n", "qualname": "WorkflowExecutor::_process_workflow_result"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow_executor.py", "kind": "comment", "text": "Update expected response count for this execution", "meta": {"scope": ["WorkflowExecutor", "_process_workflow_result"], "position": {"start": {"line": 384, "column": 8}, "end": {"line": 384, "column": 59}}, "comment_type": "block", "line_count": 1, "original_block": "        # Update expected response count for this execution\n", "qualname": "WorkflowExecutor::_process_workflow_result"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow_executor.py", "kind": "comment", "text": "Handle final state", "meta": {"scope": ["WorkflowExecutor", "_process_workflow_result"], "position": {"start": {"line": 387, "column": 8}, "end": {"line": 387, "column": 28}}, "comment_type": "block", "line_count": 1, "original_block": "        # Handle final state\n", "qualname": "WorkflowExecutor::_process_workflow_result"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow_executor.py", "kind": "comment", "text": "Find the WorkflowFailedEvent.", "meta": {"scope": ["WorkflowExecutor", "_process_workflow_result"], "position": {"start": {"line": 389, "column": 12}, "end": {"line": 389, "column": 43}}, "comment_type": "block", "line_count": 1, "original_block": "            # Find the WorkflowFailedEvent.\n", "qualname": "WorkflowExecutor::_process_workflow_result"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow_executor.py", "kind": "comment", "text": "Sub-workflow is idle - nothing more to do now", "meta": {"scope": ["WorkflowExecutor", "_process_workflow_result"], "position": {"start": {"line": 404, "column": 12}, "end": {"line": 404, "column": 59}}, "comment_type": "block", "line_count": 1, "original_block": "            # Sub-workflow is idle - nothing more to do now\n", "qualname": "WorkflowExecutor::_process_workflow_result"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow_executor.py", "kind": "comment", "text": "Treat idle as completion for now", "meta": {"scope": ["WorkflowExecutor", "_process_workflow_result"], "position": {"start": {"line": 406, "column": 42}, "end": {"line": 406, "column": 76}}, "comment_type": "inline", "original_line": "            self._active_executions -= 1  # Treat idle as completion for now\n", "qualname": "WorkflowExecutor::_process_workflow_result"}, "error": "mismatched_response"}
{"path": "/home/runner/work/translate-oss-docstring-actions/translate-oss-docstring-actions/target-repo/python/packages/core/agent_framework/_workflows/_workflow_executor.py", "kind": "comment", "text": "Sub-workflow was cancelled - treat as completion", "meta": {"scope": ["WorkflowExecutor", "_process_workflow_result"], "position": {"start": {"line": 408, "column": 12}, "end": {"line": 408, "column": 62}}, "comment_type": "block", "line_count": 1, "original_block": "            # Sub-workflow was cancelled - treat as completion\n", "qualname": "WorkflowExecutor::_process_workflow_result"}, "error": "mismatched_response"}
